# Debug80 Technical Guide

This document is the single technical reference for the Debug80 VS Code extension and debugger.
It is written for developers who have not built a VS Code extension before, and for anyone
interested in the assembler pipeline, source mapping, and stepping behavior.

## 1. What Debug80 is

Debug80 is a VS Code extension that embeds a Z80 debug adapter. It:
- Loads Intel HEX for runtime memory.
- Reads an asm80 .lst listing for address-to-source mapping.
- Optionally runs asm80 before each launch.
- Implements stepping, breakpoints, registers, and a simple terminal I/O bridge.

## 2. High-level architecture

Text diagram (left -> right = flow of control):

VS Code UI
  -> Extension activation (src/extension/extension.ts)
  -> Debug Adapter Factory (src/debug/adapter.ts)
  -> Z80DebugSession (DAP server)
  -> Z80 runtime + memory (src/z80/*)
  -> Mapping pipeline (src/mapping/*)

Key concepts:
- The extension registers a debug adapter type named `z80`.
- The debug adapter runs in-process (inline implementation), not as a separate server.
- The runtime executes Z80 instructions directly in JS/TS.

## 3. Repo layout

- src/extension/extension.ts
  - VS Code activation and command wiring.
  - Registers the debug adapter factory.
  - Hosts the terminal webview output (custom events).
- src/debug/adapter.ts
  - Main debug adapter (Z80DebugSession).
  - Launch/config merge, assembler invocation, breakpoint resolution, stepping.
- src/mapping/*
  - Listing -> segments/anchors, layer 2 matching, and index building.
- src/z80/*
  - CPU, runtime, and instruction execution.
  - HEX and listing loaders.

## 4. Extension activation and commands

Entry point: src/extension/extension.ts

Activation does three important things:
1) Registers the debug adapter for type `z80`.
2) Registers commands:
   - debug80.createProject
   - debug80.openTerminal
   - debug80.terminalInput
3) Handles the terminal webview, receiving custom output events from the adapter.

Important behavior for new VS Code extension developers:
- The debug adapter is created with vscode.DebugAdapterInlineImplementation.
- Terminal output is sent from the adapter via a custom event name:
  `debug80/terminalOutput`.

## 5. Debug Adapter Protocol (DAP) flow

Class: Z80DebugSession in src/debug/adapter.ts

DAP lifecycle (simplified):
1) initializeRequest
   - Announces adapter capabilities.
2) launchRequest
   - Merges launch args with debug80.json.
   - Resolves artifacts (HEX, LST) and runs asm80 if enabled.
   - Parses HEX and LST.
   - Builds source mapping and indexes.
   - Creates the runtime and applies breakpoints.
3) configurationDoneRequest (implicit behavior)
4) continue / step / pause / disconnect

## 6. Project configuration

### 6.1 Config file discovery

Sources are searched in this order:
1) launch args.projectConfig
2) .vscode/debug80.json
3) debug80.json
4) .debug80.json
5) package.json (debug80 block)

Search origin:
- args.asm -> args.sourceFile -> process.cwd()
- Walk upward to filesystem root, first match wins.

Note: in extension development host, process.cwd() can be the extension repo,
so root-based discovery may miss the user workspace unless debug80.json is present.

### 6.2 Launch args and target merging

Launch args are merged with config targets in populateFromConfig().
Common fields:
- sourceFile (aka asm)
- outputDir
- artifactBase
- entry
- assemble (default true)
- hex / listing (override)
- sourceRoots (list of extra source folders)
- stepOverMaxInstructions / stepOutMaxInstructions
- emitDebugMap (writes a .d8dbg.json mapping artifact)
- debugMapPath (explicit output path for the D8 map)
- terminal (I/O bridge config)

### 6.3 Scaffold command

Command: debug80.createProject
- Writes .vscode/debug80.json using inferDefaultTarget().
- Writes .vscode/launch.json if missing.
- Creates directories (outputDir, .vscode, etc).

## 7. Assembler integration (asm80)

If assemble !== false and sourceFile is provided:
- asm80 is executed with: -m Z80 -t hex -o <output hex> <sourceFile>
- The .lst generated by asm80 is copied to the desired listing path if needed.
- Errors are printed to the Debug Console (stdout/stderr).

Expected tools:
- asm80 must be installed (npm install -D asm80) or available on PATH.

## 8. Runtime and execution model

Runtime entry point: src/z80/runtime.ts

Key ideas:
- The runtime loads a 64K memory image from HEX.
- Each step executes a single instruction via execute() (src/z80/cpu.ts).
- runUntilStop loops instruction execution until a breakpoint, HALT, or pause.

Register display:
- The adapter exposes standard Z80 registers (AF, BC, DE, HL, IX, IY, etc).

## 9. Source mapping pipeline

The mapping pipeline converts a .lst listing into segments and anchors
used for breakpoints and stack frames.

### 9.1 Listing parser (Layer 1)

File: src/mapping/parser.ts

- Listing lines are detected by a leading 4-hex address.
- Byte tokens following the address determine end address.
- The remainder is captured as asmText.
- Symbol anchors are parsed from lines containing:
  "DEFINED AT LINE <n> IN <file>"

Outputs:
- segments[]: address ranges with lst text and optional source location.
- anchors[]: address -> file/line symbols.

Confidence:
- HIGH: exact anchor hit.
- MEDIUM: duplicate address or inferred between anchors.
- LOW: no anchors yet.

### 9.2 Layer 2 matching (optional refinement)

File: src/mapping/layer2.ts

- Resolves source files referenced by anchors.
- Normalizes asm lines (strip comments, uppercase, normalize whitespace).
- Searches a window around the anchor line to match lst text.
- Upgrades line accuracy where possible; downgrades data/macro regions.

Missing source files are reported to the Debug Console but are non-fatal.

### 9.3 Indexes for fast lookup

File: src/mapping/source-map.ts

Indexes built at launch:
- segmentsByAddress (sorted, for PC -> location)
- segmentsByFileLine (for breakpoint resolution)
- anchorsByFile (for fallback when no exact line match exists)

### 9.4 D8 Debug Map (D8M) format

Debug80 currently builds the mapping in memory from the .lst. The proposed
on-disk standard is documented in `docs/D8_DEBUG_MAP.md` and is designed to be
assembler-agnostic while preserving the existing LST-derived confidence data.

When `emitDebugMap` is true (or `debugMapPath` is set), Debug80 writes a
`*.d8dbg.json` file alongside the build artifacts.

## 10. Breakpoints and stack frames

### 10.1 Breakpoint resolution

- For .asm source breakpoints:
  - Resolve exact file:line to segments, else fallback to nearest anchor <= line.
- For .lst breakpoints:
  - Use listing lineToAddress map.

### 10.2 PC -> source location

- If a segment contains the PC and has loc.file, use it.
- If loc.line is missing, fallback to nearest anchor line <= PC.
- If no mapping exists, fall back to listing file/line.

## 11. Stepping behavior

Stepping combines runtime instruction execution and adapter logic.

### 11.1 Step In

- Executes one instruction and stops at the next PC.

### 11.2 Step Over

- If the current instruction is a taken CALL or RST:
  - Run until the return address is hit.
- Otherwise, step a single instruction.

Return address rules:
- CALL nn or conditional CALL: pc + 3
- RST n: pc + 1

### 11.3 Step Out

- Tracks callDepth based on taken CALL/RST and RET/RETI/RETN.
- On Step Out, run until callDepth drops below the baseline depth.

### 11.4 Step limits

Optional caps:
- stepOverMaxInstructions
- stepOutMaxInstructions

When a cap is hit:
- Execution stops and logs a console message.
- The session remains active.

## 12. Pause, HALT, and stop behavior

- Pause interrupts the run loop and stops at the current PC.
- HALT stops execution; a second Continue terminates the session.
- Stop (disconnect) terminates the session immediately.

## 13. Terminal and I/O bridge

Launch args.terminal configures a basic port-based terminal:
- txPort: output port
- rxPort: input port
- statusPort: ready/available flags
- interrupt: optional break-to-NMI behavior

Custom requests:
- debug80/terminalInput (send text to rx buffer)
- debug80/terminalBreak (trigger interrupt on next tick)

The extension receives output via debug80/terminalOutput and renders it
in a webview panel.

## 14. For developers new to VS Code extensions

Key VS Code concepts used here:
- Extension activation: register commands and debug adapter factory.
- Debug Adapter Protocol: the adapter responds to DAP requests.
- Inline debug adapter: adapter runs in the extension host process.

If you want to add features, start here:
- New launch args: update LaunchRequestArguments in src/debug/adapter.ts.
- New terminal behavior: update buildIoHandlers() in src/debug/adapter.ts.
- New mapping logic: update src/mapping/* and the index builder.

## 15. Known limitations

- Mapping accuracy depends on the quality of the .lst listing and symbols.
- process.cwd() discovery may miss the workspace in extension dev host.
- Mapping cache output is described in older specs but not implemented yet.
