rem =========================================================
rem  Data-Driven Overlay (aligned to data-driven.md)
rem =========================================================
rem  This section describes how to interpret the imperative pseudo below
rem  using the phase/rule/guard/action model in:
rem    docs/caverns/basic/data-driven.md
rem
rem  Scope note:
rem    This file contains both:
rem      1) an executable pseudo3 data-driven engine (DATA_DRIVEN_START), and
rem      2) a legacy label/goto appendix (reference only).
rem    It still does not require changes to any assembler sources; the goal is to express
rem    the conversion *in this file* first.
rem
rem  Preference rule: if anything below conflicts with this overlay,
rem  treat this overlay as the intended model (it is newer).
rem
rem  Key mappings:
rem    - OBJECT_LOCATION(ent)     -> ENTITY_LOCATION[ent]
rem    - carried (-1)             -> 0xFF
rem    - removed (0)              -> 0x00
rem    - scalar flags/vars        -> FLAGS[index]
rem    - input parsing output     -> FLAGS[FLAG_CURRENT_*]
rem
rem  Constant sources:
rem    - ROOM_* numeric constants (1..54) are defined in the legacy appendix below.
rem      The data-driven guards/actions in this overlay reference those ROOM_* symbols.
rem
rem  Phases (minimum):
rem    PHASE_DESCRIBE   : description + darkness + listing
rem    PHASE_ON_ENTER   : immediate effects after movement (bridge mid, waterfall, etc.)
rem    PHASE_ON_COMMAND : verb/movement handling based on parsed input
rem
rem  Guard encoding (Appendix B is normative):
rem    DB opcode, opA, opB   ; every guard is 3 bytes
rem    bit7 set on opcode => NOT modifier
rem    G_AND / G_OR switch boolean mode within a list
rem    G_END terminates list
rem
rem ---------------------------------------------------------
rem  Suggested FLAGS layout (indices are placeholders)
rem ---------------------------------------------------------
FLAG_HOSTILE_CREATURE_INDEX = 0    rem 0 or 1..6
FLAG_CANDLE_LIT            = 1    rem 0/1
FLAG_HUT_VISITED           = 2    rem 0/1 (pseudo3 GENERAL_FLAG_J)
FLAG_BRIDGE_CONDITION      = 10   rem 0/room/EXIT_FATAL (patched movement)
FLAG_DRAWBRIDGE_STATE      = 11   rem 0/room/EXIT_FATAL (patched movement)
FLAG_WATER_EXIT_LOCATION   = 12   rem 0/room (patched movement)
FLAG_GATE_DESTINATION      = 13   rem 0/room (patched movement)
FLAG_TELEPORT_DESTINATION  = 14   rem 0/room (patched movement)
FLAG_SECRET_EXIT_LOCATION  = 15   rem 0/room (patched movement)
FLAG_CURRENT_VERB          = 20   rem parsed verb enum
FLAG_CURRENT_DIR           = 21   rem 0..3, or 0xFF for none
FLAG_CURRENT_OBJECT        = 22   rem 0 or 7..24
FLAG_SPECIAL_WORD          = 23   rem enum: none/look/list/quit/galar/ape
FLAG_SWORD_SWING_COUNT     = 30
FLAG_SCORE                 = 31

rem ---------------------------------------------------------
rem  Entry point
rem ---------------------------------------------------------
rem Default entry for this file is the data-driven engine.
goto DATA_DRIVEN_START

rem ---------------------------------------------------------
rem  Parser enums (byte values)
rem ---------------------------------------------------------
rem These values are what ACT_PARSE_INPUT writes into the FLAG_CURRENT_* flags.

rem FLAG_SPECIAL_WORD (fast-path commands / magic words)
SPECIAL_NONE  = 0
SPECIAL_LOOK  = 1
SPECIAL_LIST  = 2
SPECIAL_QUIT  = 3
SPECIAL_GALAR = 4
SPECIAL_APE   = 5

rem FLAG_CURRENT_VERB (normalized verbs)
VERB_NONE = 0
VERB_GET  = 1
VERB_DROP = 2
VERB_USE  = 3

rem Optional: map legacy VERB_PATTERN_INDEX behaviors to verbs
rem   TAKE -> VERB_GET
rem   PUT  -> VERB_DROP
rem   USING/WITH -> VERB_USE
rem Everything else can remain "pattern response" (handled by a separate rule group if desired).

rem ---------------------------------------------------------
rem  Text IDs (assign new IDs)
rem ---------------------------------------------------------
rem Use these as stable identifiers for `ACT_PRINT_TEXT(TEXT_*)` (or as indices into a text pointer table).
rem These are the canonical IDs for legacy string literals in the appendix below.
rem
rem Implementation guidance (no code changes required here):
rem   In the target assembler/runtime, define a `TEXT_PTR_TABLE[TEXT_*] -> stringPtr` so
rem   actions can print via IDs instead of hardcoding string labels.

TEXT_DARKNESS                     = 1
TEXT_DRAINAGE_SYSTEM              = 2
TEXT_DEEP_DARK_CAVERN             = 3
TEXT_BRIDGE_ROPES_SNAPPED         = 4
TEXT_DRAGON_CORPSE                = 5
TEXT_DRAWBRIDGE_SPANS_WATERS      = 6
TEXT_CANDLE_GROWING_DIM           = 7
TEXT_CANDLE_WENT_OUT              = 8

TEXT_YOU_CAN_ALSO_SEE             = 9
TEXT_NEARBY_THERE_LURKS           = 10
TEXT_PROMPT                       = 11

TEXT_INVENTORY_PREFIX             = 12   rem "You are carrying "
TEXT_INVENTORY_NOTHING            = 13   rem "nothing."

TEXT_SCORE_LINE                   = 14   rem formatted line in ACT_QUIT_AND_SCORE
TEXT_ANOTHER_ADVENTURE            = 15

TEXT_BAT_CARRIES_YOU              = 16
TEXT_MONSTER_KILLS_YOU            = 17   rem formatted line in ACT_MONSTER_ATTACK_AND_KILL

TEXT_CANT_GO_THAT_WAY             = 18
TEXT_FALL_AND_DIE                 = 19

TEXT_TELEPORT_WIND                = 20
TEXT_CRYPT_WALL_OPENS             = 21

TEXT_EH                           = 22
TEXT_WHERE_CANT_SEE_IT            = 23
TEXT_TOO_MANY_OBJECTS             = 24
TEXT_DONT_KNOW_HOW_TO_USE         = 25

TEXT_IT_WONT_OPEN                 = 26
TEXT_OPENED_THE_DOOR              = 27

TEXT_NOTHING_TO_KILL              = 28
TEXT_SWORD_MISS_YOU_DIE           = 29
TEXT_SWORD_ATTACK_MISSED          = 30
TEXT_SWORD_DEFLECTED              = 31
TEXT_SWORD_STUNNED                = 32
TEXT_SWORD_YOU_GOT_HIT            = 33
TEXT_SWORD_STRIKES_HOME           = 34
TEXT_SWORD_CRUMBLES               = 35
TEXT_CORPSE_VAPORIZES             = 36

TEXT_BOMB_WONT_BURN_CANDLE_OUT     = 37
TEXT_CANDLE_OUT_INSULT            = 38
TEXT_BOMB_BOOM_LUCKY              = 39

TEXT_TOO_DANGEROUS                = 40
TEXT_ROPE_DESCEND                 = 41

TEXT_PATTERN_NOTHING_HAPPENS       = 42
TEXT_PATTERN_PLEASE_TELL_ME_HOW    = 43
TEXT_PATTERN_I_CANT               = 44

TEXT_RANKING_HEADER               = 45
TEXT_RANKING_HOPELESS_BEGINNER     = 46
TEXT_RANKING_EXPERIENCED_LOSER     = 47
TEXT_RANKING_AVERAGE_VIKING        = 48
TEXT_RANKING_EXCELLENT_LEFT_BEHIND = 49
TEXT_RANKING_PERFECTIONIST        = 50

TEXT_ENCOUNTER_WIZARD              = 51
TEXT_ENCOUNTER_DRAGON_1            = 52
TEXT_ENCOUNTER_DRAGON_2            = 53
TEXT_ENCOUNTER_DWARF               = 54

rem ---------------------------------------------------------
rem  Action inventory (map these to assembler routines)
rem ---------------------------------------------------------
rem Output:
rem   ACT_PRINT_ROOM_DESCRIPTION_PTRS
rem   ACT_PRINT_DARKNESS_MESSAGE
rem   ACT_PRINT_ROOM_EXTRAS
rem   ACT_LIST_VISIBLE_ENTITIES
rem   ACT_PROMPT
rem Parsing:
rem   ACT_READ_INPUT_AND_NORMALIZE
rem   ACT_PARSE_INPUT
rem Hostile/combat:
rem   ACT_UPDATE_HOSTILE_CREATURE_INDEX
rem   ACT_MONSTER_ATTACK_AND_KILL
rem   ACT_SWORD_COMBAT
rem Movement:
rem   ACT_RESOLVE_MOVEMENT               ; uses MOVEMENT_TABLE and EXIT_NONE/EXIT_FATAL
rem   ACT_PATCH_DYNAMIC_EXITS            ; implements UPDATE_DYNAMIC_EXITS_SUB as a single action
rem Inventory:
rem   ACT_PRINT_INVENTORY
rem   ACT_TRY_GET_CURRENT_OBJECT
rem   ACT_DROP_CURRENT_OBJECT
rem Game-specific:
rem   ACT_USE_KEY
rem   ACT_USE_BOMB
rem   ACT_USE_ROPE
rem Quit/scoring:
rem   ACT_QUIT_AND_SCORE

rem ---------------------------------------------------------
rem  Step 5: Action specs (inputs/outputs/side effects)
rem ---------------------------------------------------------
rem Each action below is an imperative routine called by the interpreter.
rem It may read/write `PLAYER_LOCATION`, `TURN_COUNTER`, `PLAYER_ALIVE`,
rem `ENTITY_LOCATION[]`, and `FLAGS[]`, but MUST NOT call back into rule evaluation.
rem
rem Naming convention: actions referenced by RULE_TABLE should appear here.

rem --- Core loop helpers (called outside phases) ---
rem ACT_READ_INPUT_AND_NORMALIZE
rem   Reads: keyboard input
rem   Writes:
rem     - normalized input buffer (implementation-specific)
rem     - TURN_COUNTER++
rem
rem ACT_PARSE_INPUT
rem   Reads: normalized input buffer, VERB_PATTERN_DATA, DIR_WORD_INDEX_DATA, OBJECT_NAME_NOUN_DATA
rem   Writes:
rem     - FLAGS[FLAG_SPECIAL_WORD] (SPECIAL_*)
rem     - FLAGS[FLAG_CURRENT_VERB] (VERB_*)
rem     - FLAGS[FLAG_CURRENT_DIR] (0..3 or 0xFF)
rem     - FLAGS[FLAG_CURRENT_OBJECT] (0 or 7..24)
rem     - FLAGS[FLAG_VERB_PATTERN_INDEX] (0 if none, else 1..16)
rem
rem ACT_UPDATE_HOSTILE_CREATURE_INDEX
rem   Reads: PLAYER_LOCATION, ENTITY_LOCATION[1..6]
rem   Writes: FLAGS[FLAG_HOSTILE_CREATURE_INDEX] = 0 or creature id

rem --- PHASE_DESCRIBE actions ---
rem ACT_DESCRIBE_LIT
rem   Reads: PLAYER_LOCATION, ROOM_DESC1_PTR, ROOM_DESC2_PTR, TURN_COUNTER, FLAGS (dynamic exit flags), ENTITY_LOCATION
rem   Writes: (output only; may also clear candle flag if turn threshold exceeded)
rem   Output sequence (matches pseudo3 intent):
rem     1) room description pointers (if non-null)
rem     2) extras (drainage/deep cavern/bridge ropes/dragon corpse/drawbridge/candle dim/out):
rem          - TEXT_DRAINAGE_SYSTEM
rem          - TEXT_DEEP_DARK_CAVERN
rem          - TEXT_BRIDGE_ROPES_SNAPPED
rem          - TEXT_DRAGON_CORPSE
rem          - TEXT_DRAWBRIDGE_SPANS_WATERS
rem          - TEXT_CANDLE_GROWING_DIM
rem          - TEXT_CANDLE_WENT_OUT
rem     3) list visible objects and creatures (with creature intro text)
rem          - TEXT_YOU_CAN_ALSO_SEE / TEXT_NEARBY_THERE_LURKS
rem     4) prompt ">" (TEXT_PROMPT)
rem
rem ACT_DESCRIBE_DARK
rem   Reads: PLAYER_LOCATION, TURN_COUNTER, FLAGS, ENTITY_LOCATION
rem   Writes: (output only)
rem   Output sequence:
rem     1) darkness message (TEXT_DARKNESS)
rem     2) list visible objects/creatures (note: pseudo3 still lists after darkness)
rem     3) prompt ">"
rem
rem ACT_MONSTER_ATTACK_AND_KILL
rem   Reads: FLAGS[FLAG_HOSTILE_CREATURE_INDEX], MONSTER_ADJ_DATA, MONSTER_NOUN_DATA
rem   Writes:
rem     - PLAYER_ALIVE = 0
rem   Output: killed-by-hostile message (TEXT_MONSTER_KILLS_YOU, formatted with adj/noun)
rem   Next: main loop should transition to quit/scoring flow (or treat PLAYER_ALIVE==0 as exit).

rem --- PHASE_ON_COMMAND actions ---
rem ACT_FORCE_REDESCRIBE
rem   Writes: (optional) FLAGS[RESHOW] = 0
rem   Effect: no state change; main loop should run PHASE_DESCRIBE immediately.
rem
rem ACT_PRINT_INVENTORY
rem   Reads: ENTITY_LOCATION[7..24], OBJDESC tables
rem   Writes: output only
rem
rem ACT_QUIT_AND_SCORE
rem   Reads: TURN_COUNTER, ENTITY_LOCATION[7..17]
rem   Writes:
rem     - FLAGS[FLAG_SCORE]
rem     - PLAYER_ALIVE = 0 (terminate)
rem   Output: score line + ranking + restart prompt (restart handling can remain outside rule engine).
rem
rem ACT_TELEPORT_TO_CAVE_ENTRY
rem   Writes: PLAYER_LOCATION = ROOM_CAVE_ENTRY
rem   Output: teleport message (TEXT_TELEPORT_WIND)
rem   Next: main loop should run PHASE_ON_ENTER then PHASE_DESCRIBE.
rem
rem ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH
rem   Writes:
rem     - FLAGS[FLAG_SECRET_EXIT_LOCATION] = ROOM_TINY_CELL (38 in pseudo3)
rem     - calls ACT_PATCH_DYNAMIC_EXITS effect (see below)
rem   Output: crypt wall message (TEXT_CRYPT_WALL_OPENS)
rem
rem ACT_PRINT_EH
rem   Output: TEXT_EH
rem
rem ACT_PRINT_WHERE_I_CANT_SEE_IT
rem   Output: TEXT_WHERE_CANT_SEE_IT
rem
rem ACT_TRY_GET_CURRENT_OBJECT
rem   Reads: FLAGS[FLAG_CURRENT_OBJECT], ENTITY_LOCATION[7..24]
rem   Writes:
rem     - if carried count > 10: output TEXT_TOO_MANY_OBJECTS
rem     - else ENTITY_LOCATION[obj] = 0xFF
rem
rem ACT_DROP_CURRENT_OBJECT
rem   Reads: FLAGS[FLAG_CURRENT_OBJECT]
rem   Writes: ENTITY_LOCATION[obj] = PLAYER_LOCATION
rem
rem ACT_PRINT_IT_WONT_OPEN
rem   Output: TEXT_IT_WONT_OPEN
rem
rem ACT_USE_KEY_FOREST
rem   Preconditions: at ROOM_FOREST_CLEARING
rem   Writes:
rem     - ENTITY_LOCATION[OBJ_KEY] = PLAYER_LOCATION (matches pseudo3 "drop key")
rem     - PLAYER_LOCATION = ROOM_DARK_ROOM
rem   Output: TEXT_OPENED_THE_DOOR
rem
rem ACT_USE_KEY_TEMPLE
rem   Preconditions: at ROOM_TEMPLE
rem   Writes:
rem     - ENTITY_LOCATION[OBJ_KEY] = PLAYER_LOCATION
rem     - PLAYER_LOCATION = ROOM_CRYPT
rem   Output: TEXT_OPENED_THE_DOOR
rem
rem ACT_PRINT_NOTHING_TO_KILL
rem   Output: TEXT_NOTHING_TO_KILL
rem
rem ACT_SWORD_COMBAT
rem   Reads: FLAGS[FLAG_HOSTILE_CREATURE_INDEX], FLAGS[FLAG_SWORD_SWING_COUNT], RNG
rem   Writes:
rem     - FLAGS[FLAG_SWORD_SWING_COUNT]++
rem     - may set PLAYER_ALIVE=0
rem     - may remove hostile creature (ENTITY_LOCATION[creature]=0) and emit extra messages
rem     - wizard special: crumble sword and relocate sword entity
rem   Output: combat messages:
rem     - TEXT_SWORD_MISS_YOU_DIE
rem     - TEXT_SWORD_ATTACK_MISSED / TEXT_SWORD_DEFLECTED / TEXT_SWORD_STUNNED / TEXT_SWORD_YOU_GOT_HIT
rem     - TEXT_SWORD_STRIKES_HOME
rem     - TEXT_SWORD_CRUMBLES
rem     - TEXT_CORPSE_VAPORIZES
rem
rem ACT_USE_BOMB
rem   Reads: ENTITY_LOCATION[OBJ_BOMB], FLAGS[FLAG_CANDLE_LIT], PLAYER_LOCATION, RNG (if any)
rem   Writes:
rem     - may clear FLAGS[FLAG_CANDLE_LIT]
rem     - may move player back one room
rem     - ENTITY_LOCATION[OBJ_BOMB] = 0 (removed)
rem     - may set FLAGS[FLAG_TELEPORT_DESTINATION] and patch exits if player reaches oak door
rem   Output:
rem     - TEXT_BOMB_WONT_BURN_CANDLE_OUT
rem     - TEXT_CANDLE_OUT_INSULT
rem     - TEXT_BOMB_BOOM_LUCKY
rem
rem ACT_PRINT_TOO_DANGEROUS
rem   Output: TEXT_TOO_DANGEROUS
rem
rem ACT_USE_ROPE
rem   Preconditions: at ROOM_TEMPLE_BALCONY
rem   Writes:
rem     - ENTITY_LOCATION[OBJ_ROPE] = PLAYER_LOCATION (drops rope)
rem     - PLAYER_LOCATION = ROOM_TEMPLE
rem   Output: TEXT_ROPE_DESCEND
rem
rem ACT_PRINT_PATTERN_RESPONSE
rem   Reads: FLAGS[FLAG_VERB_PATTERN_INDEX]
rem   Output: legacy canned responses:
rem     - cut/break -> TEXT_PATTERN_NOTHING_HAPPENS
rem     - unlock/open/kill/attack/light/burn -> TEXT_PATTERN_PLEASE_TELL_ME_HOW
rem     - up/down/jump/swim -> TEXT_PATTERN_I_CANT
rem   Notes: TAKE/PUT/USING/WITH should be normalized by ACT_PARSE_INPUT into VERB_GET/VERB_DROP/VERB_USE instead.

rem ACT_RESOLVE_MOVEMENT
rem   Reads: PLAYER_LOCATION, FLAGS[FLAG_CURRENT_DIR], MOVEMENT_TABLE, ENTITY_LOCATION[OBJ_BOMB]
rem   Writes:
rem     - possibly PLAYER_LOCATION (move)
rem     - possibly PLAYER_ALIVE=0 on fatal exit
rem   Output:
rem     - EXIT_NONE -> TEXT_CANT_GO_THAT_WAY
rem     - EXIT_FATAL -> TEXT_FALL_AND_DIE
rem   Notes: pseudo3 likely has a bug here (typed direction is ignored).
rem     Suggested behavior:
rem       dir = FLAGS[FLAG_CURRENT_DIR]
rem       if (bomb exists) AND (bomb not carried) AND (bomb not at player):
rem         dir = random(0..3)
rem       target = MOVEMENT_TABLE[PLAYER_LOCATION][dir]

rem --- PHASE_ON_ENTER actions (dynamic state) ---
rem ACT_SET_BRIDGE_FATAL_AND_PATCH
rem   Writes:
rem     - FLAGS[FLAG_BRIDGE_CONDITION] = EXIT_FATAL
rem     - ACT_PATCH_DYNAMIC_EXITS effect
rem
rem ACT_SET_HUT_VISITED
rem   Writes: FLAGS[FLAG_HUT_VISITED]=1 (if you keep it; pseudo3 uses GENERAL_FLAG_J)
rem
rem ACT_ENABLE_WATER_EXIT_AND_PATCH
rem   Writes:
rem     - FLAGS[FLAG_WATER_EXIT_LOCATION] = ROOM_DRAIN_C (43)
rem     - patch exits
rem
rem ACT_DISABLE_WATER_EXIT_AND_PATCH
rem   Writes:
rem     - FLAGS[FLAG_WATER_EXIT_LOCATION] = 0
rem     - patch exits
rem
rem ACT_SET_GATE_DEST_AND_PATCH
rem   Writes:
rem     - FLAGS[FLAG_GATE_DESTINATION] = ROOM_DARK_CAVERN_J (39)
rem     - patch exits
rem
rem ACT_SET_DRAWBRIDGE_AND_PATCH
rem   Writes:
rem     - FLAGS[FLAG_DRAWBRIDGE_STATE] = ROOM_DRAWBRIDGE (49)
rem     - patch exits
rem
rem ACT_PATCH_DYNAMIC_EXITS
rem   Writes: MOVEMENT_TABLE slot patches (see mapping above)
rem
rem ACT_BAT_CARRY
rem   Writes:
rem     - output carry message (TEXT_BAT_CARRIES_YOU)
rem     - PLAYER_LOCATION = ROOM_BAT_CAVE
rem     - mutate bat location (pseudo3 does OBJECT_LOCATION(5) += 7)
rem       Suggested ENTITY_LOCATION[] meaning:
rem         - let oldRoom = ENTITY_LOCATION[ENT_BAT]
rem         - set ENTITY_LOCATION[ENT_BAT] = oldRoom + 7
rem         - if result > ROOM_MAX, wrap to ROOM_BAT_CAVE (keeps within valid room ids)
rem       Rationale: preserves the original “bat moves away” behavior without adding new state.
rem
rem ACT_NOOP
rem   No effect

rem ---------------------------------------------------------
rem  Step 6: Legacy label -> rule/action mapping
rem ---------------------------------------------------------
rem This provides a mechanical translation path from the imperative sections below.
rem Format:
rem   LEGACY_LABEL -> phase(s) -> rule(s) -> action(s)
rem
rem GAME_START
rem   -> engine init (outside phases):
rem      - initialize PLAYER_LOCATION, ENTITY_LOCATION[], FLAGS[] to match old variables
rem      - call ACT_PATCH_DYNAMIC_EXITS once after initializing dynamic-exit flags
rem      - enter main loop (read/parse/update-hostile/run phases)
rem
rem DESCRIBE_CURRENT_LOCATION
rem   -> PHASE_DESCRIBE:
rem      - GUARD_HOSTILE_ATTACKABLE -> ACT_MONSTER_ATTACK_AND_KILL
rem      - GUARD_BRIGHT_BY_ROOM -> ACT_DESCRIBE_LIT
rem      - GUARD_BRIGHT_BY_CANDLE -> ACT_DESCRIBE_LIT
rem      - GUARD_ALWAYS -> ACT_DESCRIBE_DARK
rem
rem PRINT_ROOM_DESCRIPTION
rem   -> folded into ACT_DESCRIBE_LIT (room pointer printing) + ACT_PRINT_ROOM_EXTRAS
rem
rem LIST_ROOM_OBJECTS_AND_CREATURES
rem   -> folded into ACT_LIST_VISIBLE_ENTITIES (called by ACT_DESCRIBE_* composite output)
rem
rem GET_PLAYER_INPUT
rem   -> ACT_READ_INPUT_AND_NORMALIZE (outside phases)
rem
rem PARSE_COMMAND_ENTRY
rem   -> ACT_PARSE_INPUT (outside phases) + (dynamic exit updates move to PHASE_ON_ENTER)
rem
rem SHOW_INVENTORY
rem   -> PHASE_ON_COMMAND:
rem      - GUARD_SPECIAL_LIST -> ACT_PRINT_INVENTORY
rem
rem QUIT_GAME + WAIT_FOR_YES_NO + PRINT_RANKING_SUB
rem   -> PHASE_ON_COMMAND:
rem      - GUARD_SPECIAL_QUIT -> ACT_QUIT_AND_SCORE
rem   -> restart prompt can remain outside interpreter (shell loop) or become a post-action flow.
rem
rem CHECK_CREATURE_AT_LOCATION
rem   -> ACT_UPDATE_HOSTILE_CREATURE_INDEX (outside phases)
rem
rem CHECK_CREATURE_BAT_SPECIAL
rem   -> PHASE_ON_ENTER:
rem      - GUARD_BAT_PRESENT -> ACT_BAT_CARRY
rem   (bat carry is an enter-time effect in practice; keep it here to avoid mixing with command rules)
rem
rem MONSTER_ATTACK
rem   -> ACT_MONSTER_ATTACK_AND_KILL (invoked by PHASE_DESCRIBE rule)
rem
rem HANDLE_VERB_OR_MOVEMENT + ROUTE_BY_VERB_PATTERN
rem   -> ACT_PARSE_INPUT sets:
rem        - VERB_GET / VERB_DROP / VERB_USE where applicable
rem        - FLAG_VERB_PATTERN_INDEX for all other matches
rem   -> PHASE_ON_COMMAND:
rem        - GUARD_VERB_GET / GUARD_VERB_DROP / (USE guards) / GUARD_PATTERN_RESPONSE
rem
rem HANDLE_MOVEMENT_COMMAND
rem   -> PHASE_ON_COMMAND:
rem        - GUARD_HAS_DIRECTION -> ACT_RESOLVE_MOVEMENT
rem   -> after successful move: PHASE_ON_ENTER runs, then PHASE_DESCRIBE.
rem
rem HANDLE_NON_MOVEMENT_COMMAND
rem   -> PHASE_ON_COMMAND special words:
rem        - GUARD_SPECIAL_GALAR -> ACT_TELEPORT_TO_CAVE_ENTRY
rem        - GUARD_SPECIAL_APE   -> ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH
rem        - fallback -> ACT_PRINT_EH
rem
rem CHECK_GET_DROP_USE + HANDLE_GET_COMMAND + HANDLE_DROP_COMMAND
rem   -> PHASE_ON_COMMAND:
rem        - GUARD_OBJECT_NOT_VISIBLE -> ACT_PRINT_WHERE_I_CANT_SEE_IT
rem        - GUARD_VERB_GET -> ACT_TRY_GET_CURRENT_OBJECT
rem        - GUARD_VERB_DROP -> ACT_DROP_CURRENT_OBJECT
rem
rem ROUTE_USE_BY_OBJECT
rem   -> PHASE_ON_COMMAND:
rem        - KEY rules -> ACT_USE_KEY_FOREST / ACT_USE_KEY_TEMPLE / ACT_PRINT_IT_WONT_OPEN
rem        - SWORD rules -> ACT_SWORD_COMBAT / ACT_PRINT_NOTHING_TO_KILL
rem        - CANDLE->BOMB rule -> ACT_USE_BOMB
rem        - ROPE rules -> ACT_USE_ROPE / ACT_PRINT_TOO_DANGEROUS
rem        - else -> ACT_PRINT_PATTERN_RESPONSE or a dedicated ACT_PRINT_DONT_KNOW_HOW_TO_USE
rem
rem USE_KEY
rem   -> split by location (two rules already in RULE_TABLE):
rem        - GUARD_USE_KEY_FOREST -> ACT_USE_KEY_FOREST
rem        - GUARD_USE_KEY_TEMPLE -> ACT_USE_KEY_TEMPLE
rem        - GUARD_USE_KEY_BAD_LOCATION -> ACT_PRINT_IT_WONT_OPEN
rem
rem USE_SWORD + SWORD_FIGHT_CONTINUES + SWORD_KILLS_TARGET
rem   -> single action ACT_SWORD_COMBAT invoked by GUARD_USE_SWORD_HOSTILE
rem
rem USE_BOMB
rem   -> single action ACT_USE_BOMB invoked by GUARD_USE_BOMB
rem
rem USE_ROPE
rem   -> split by location:
rem        - GUARD_USE_ROPE_OK -> ACT_USE_ROPE
rem        - GUARD_USE_ROPE_BAD_LOCATION -> ACT_PRINT_TOO_DANGEROUS
rem
rem UPDATE_DYNAMIC_EXITS_SUB
rem   -> single action ACT_PATCH_DYNAMIC_EXITS
rem   -> called by the *_AND_PATCH on-enter actions and by APE/open-secret-exit action.

rem ---------------------------------------------------------
rem  Data tables (how actions consume the existing tables)
rem ---------------------------------------------------------
rem Room text:
rem   ROOM_DESC1_PTR(room), ROOM_DESC2_PTR(room) -> used by ACT_PRINT_ROOM_DESCRIPTION_PTRS
rem
rem Entity descriptions:
rem   OBJDESC1(ent), OBJDESC2(ent) -> used by ACT_LIST_VISIBLE_ENTITIES and ACT_PRINT_INVENTORY
rem   MONSTER_ADJ(creature), MONSTER_NOUN(creature) -> used by ACT_MONSTER_ATTACK_AND_KILL
rem
rem Input parsing tables:
rem   VERB_PATTERN[] and DIR_WORD_INDEX[] -> used by ACT_PARSE_INPUT
rem
rem Movement:
rem   MOVEMENT_TABLE[room][dir] -> used by ACT_RESOLVE_MOVEMENT
rem   Dynamic patch slots (from UPDATE_DYNAMIC_EXITS_SUB) become writes in ACT_PATCH_DYNAMIC_EXITS:
rem     (ROOM_BRIDGE_NORTH_ANCHOR, DIR_SOUTH_STR) = FLAG_BRIDGE_CONDITION
rem     (ROOM_BRIDGE_SOUTH_ANCHOR, DIR_NORTH_STR) = FLAG_BRIDGE_CONDITION
rem     (ROOM_OAK_DOOR,            DIR_EAST_STR)  = FLAG_TELEPORT_DESTINATION
rem     (ROOM_CRYPT,               DIR_EAST_STR)  = FLAG_SECRET_EXIT_LOCATION
rem     (ROOM_TINY_CELL,           DIR_NORTH_STR) = FLAG_WATER_EXIT_LOCATION
rem     (ROOM_TINY_CELL,           DIR_EAST_STR)  = FLAG_GATE_DESTINATION
rem     (ROOM_CASTLE_LEDGE,        DIR_EAST_STR)  = FLAG_DRAWBRIDGE_STATE
rem
rem ---------------------------------------------------------
rem  Representative rules (sketch)
rem ---------------------------------------------------------
rem PHASE_DESCRIBE:
rem   - hostile attack gating (not bat, and not currently using sword)
rem   - darkness rules (bright-by-room, bright-by-candle-visible, fallback darkness message)
rem   - then extras/list/prompt (either as a composite action, or as a fixed post-step)
rem
rem PHASE_ON_ENTER:
rem   - if at bridge mid: set FLAG_BRIDGE_CONDITION=EXIT_FATAL; ACT_PATCH_DYNAMIC_EXITS
rem   - if at waterfall base: set FLAG_WATER_EXIT_LOCATION=43; patch
rem   - if at temple: set FLAG_WATER_EXIT_LOCATION=0; patch
rem   - if grill not in tiny cell: set FLAG_GATE_DESTINATION=39; patch
rem   - if at drawbridge room: set FLAG_DRAWBRIDGE_STATE=49; patch
rem
rem PHASE_ON_COMMAND:
rem   - special words: LOOK/LIST/QUIT/GALAR/APE
rem   - movement if FLAG_CURRENT_DIR != 0xFF
rem   - object visibility gate (must be carried or at player)
rem   - GET/DROP
rem   - USE routing (key/sword/bomb/rope)
rem
rem ---------------------------------------------------------
rem  RULE_TABLE skeleton (concrete; ordered; per phase)
rem ---------------------------------------------------------
rem Record layout (assembler-friendly):
rem   DB phaseId
rem   DW guardListPtr
rem   DW actionPtr
rem
rem Notes:
rem - These rules intentionally reference guard/action symbols that are defined later in this overlay
rem   or will be implemented as assembler routines. Step 4 will provide the full guard lists.
rem - First matching rule terminates the phase.
rem
RULE_TABLE:

rem --- PHASE_ON_COMMAND ---
    DB PHASE_ON_COMMAND: DW GUARD_SPECIAL_LOOK:        DW ACT_FORCE_REDESCRIBE
    DB PHASE_ON_COMMAND: DW GUARD_SPECIAL_LIST:        DW ACT_PRINT_INVENTORY
    DB PHASE_ON_COMMAND: DW GUARD_SPECIAL_QUIT:        DW ACT_QUIT_AND_SCORE
    DB PHASE_ON_COMMAND: DW GUARD_SPECIAL_GALAR:       DW ACT_TELEPORT_TO_CAVE_ENTRY
    DB PHASE_ON_COMMAND: DW GUARD_SPECIAL_APE:         DW ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH

    DB PHASE_ON_COMMAND: DW GUARD_HAS_DIRECTION:       DW ACT_RESOLVE_MOVEMENT

    DB PHASE_ON_COMMAND: DW GUARD_NO_OBJECT_PARSED:    DW ACT_PRINT_EH
    DB PHASE_ON_COMMAND: DW GUARD_OBJECT_NOT_VISIBLE:  DW ACT_PRINT_WHERE_I_CANT_SEE_IT

    DB PHASE_ON_COMMAND: DW GUARD_VERB_GET:            DW ACT_TRY_GET_CURRENT_OBJECT
    DB PHASE_ON_COMMAND: DW GUARD_VERB_DROP:           DW ACT_DROP_CURRENT_OBJECT

    DB PHASE_ON_COMMAND: DW GUARD_USE_KEY_BAD_LOCATION: DW ACT_PRINT_IT_WONT_OPEN
    DB PHASE_ON_COMMAND: DW GUARD_USE_KEY_FOREST:       DW ACT_USE_KEY_FOREST
    DB PHASE_ON_COMMAND: DW GUARD_USE_KEY_TEMPLE:       DW ACT_USE_KEY_TEMPLE

    DB PHASE_ON_COMMAND: DW GUARD_USE_SWORD_NO_HOSTILE: DW ACT_PRINT_NOTHING_TO_KILL
    DB PHASE_ON_COMMAND: DW GUARD_USE_SWORD_HOSTILE:    DW ACT_SWORD_COMBAT

    DB PHASE_ON_COMMAND: DW GUARD_USE_BOMB:             DW ACT_USE_BOMB
    DB PHASE_ON_COMMAND: DW GUARD_USE_ROPE_BAD_LOCATION:DW ACT_PRINT_TOO_DANGEROUS
    DB PHASE_ON_COMMAND: DW GUARD_USE_ROPE_OK:          DW ACT_USE_ROPE

    DB PHASE_ON_COMMAND: DW GUARD_PATTERN_RESPONSE:     DW ACT_PRINT_PATTERN_RESPONSE

    DB PHASE_ON_COMMAND: DW GUARD_ALWAYS:               DW ACT_PRINT_EH

rem --- PHASE_ON_ENTER ---
    DB PHASE_ON_ENTER: DW GUARD_AT_BRIDGE_MID:        DW ACT_SET_BRIDGE_FATAL_AND_PATCH
    DB PHASE_ON_ENTER: DW GUARD_AT_FOREST_CLEARING:   DW ACT_SET_HUT_VISITED
    DB PHASE_ON_ENTER: DW GUARD_AT_WATERFALL_BASE:    DW ACT_ENABLE_WATER_EXIT_AND_PATCH
    DB PHASE_ON_ENTER: DW GUARD_AT_TEMPLE:            DW ACT_DISABLE_WATER_EXIT_AND_PATCH
    DB PHASE_ON_ENTER: DW GUARD_GRILL_NOT_IN_TINY_CELL: DW ACT_SET_GATE_DEST_AND_PATCH
    DB PHASE_ON_ENTER: DW GUARD_AT_DRAWBRIDGE:        DW ACT_SET_DRAWBRIDGE_AND_PATCH

    DB PHASE_ON_ENTER: DW GUARD_BAT_PRESENT:          DW ACT_BAT_CARRY

    DB PHASE_ON_ENTER: DW GUARD_ALWAYS:               DW ACT_NOOP

rem --- PHASE_DESCRIBE ---
    DB PHASE_DESCRIBE: DW GUARD_HOSTILE_ATTACKABLE:   DW ACT_MONSTER_ATTACK_AND_KILL

    DB PHASE_DESCRIBE: DW GUARD_BRIGHT_BY_ROOM:       DW ACT_DESCRIBE_LIT
    DB PHASE_DESCRIBE: DW GUARD_BRIGHT_BY_CANDLE:     DW ACT_DESCRIBE_LIT
    DB PHASE_DESCRIBE: DW GUARD_ALWAYS:               DW ACT_DESCRIBE_DARK

rem ---------------------------------------------------------
rem  Guard list definitions (fixed 3-byte guards)
rem ---------------------------------------------------------
rem All guard lists end with: DB G_END, 0, 0

GUARD_ALWAYS:
    DB G_END, 0, 0

rem --- Special words ---
GUARD_SPECIAL_LOOK:
    DB G_FLAG_EQ, FLAG_SPECIAL_WORD, SPECIAL_LOOK
    DB G_END, 0, 0

GUARD_SPECIAL_LIST:
    DB G_FLAG_EQ, FLAG_SPECIAL_WORD, SPECIAL_LIST
    DB G_END, 0, 0

GUARD_SPECIAL_QUIT:
    DB G_FLAG_EQ, FLAG_SPECIAL_WORD, SPECIAL_QUIT
    DB G_END, 0, 0

GUARD_SPECIAL_GALAR:
    DB G_FLAG_EQ, FLAG_SPECIAL_WORD, SPECIAL_GALAR
    DB G_END, 0, 0

GUARD_SPECIAL_APE:
    DB G_FLAG_EQ, FLAG_SPECIAL_WORD, SPECIAL_APE
    DB G_END, 0, 0

rem --- Movement ---
GUARD_HAS_DIRECTION:
    DB G_FLAG_NE, FLAG_CURRENT_DIR, 255
    DB G_END, 0, 0

rem --- Object routing / visibility ---
GUARD_NO_OBJECT_PARSED:
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, 0
    DB G_END, 0, 0

GUARD_OBJECT_NOT_VISIBLE:
    DB G_FLAG_NE, FLAG_CURRENT_OBJECT, 0
    DB 0x80 + G_ENT_VISIBLE_CURRENT, FLAG_CURRENT_OBJECT, 0
    DB G_END, 0, 0

rem --- Inventory verbs ---
GUARD_VERB_GET:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_GET
    DB G_END, 0, 0

GUARD_VERB_DROP:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_DROP
    DB G_END, 0, 0

rem --- USE: KEY ---
GUARD_USE_KEY_BAD_LOCATION:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_KEY
    DB 0x80 + G_AT, ROOM_FOREST_CLEARING, 0
    DB 0x80 + G_AT, ROOM_TEMPLE, 0
    DB G_END, 0, 0

GUARD_USE_KEY_FOREST:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_KEY
    DB G_AT, ROOM_FOREST_CLEARING, 0
    DB G_END, 0, 0

GUARD_USE_KEY_TEMPLE:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_KEY
    DB G_AT, ROOM_TEMPLE, 0
    DB G_END, 0, 0

rem --- USE: SWORD ---
GUARD_USE_SWORD_NO_HOSTILE:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_SWORD
    DB G_FLAG_EQ, FLAG_HOSTILE_CREATURE_INDEX, 0
    DB G_END, 0, 0

GUARD_USE_SWORD_HOSTILE:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_SWORD
    DB G_FLAG_NE, FLAG_HOSTILE_CREATURE_INDEX, 0
    DB G_END, 0, 0

rem --- USE: BOMB (pseudo3 routes candle -> bomb logic) ---
GUARD_USE_BOMB:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_CANDLE
    DB G_END, 0, 0

rem --- USE: ROPE ---
GUARD_USE_ROPE_BAD_LOCATION:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_ROPE
    DB 0x80 + G_AT, ROOM_TEMPLE_BALCONY, 0
    DB G_END, 0, 0

GUARD_USE_ROPE_OK:
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_USE
    DB G_FLAG_EQ, FLAG_CURRENT_OBJECT, OBJ_ROPE
    DB G_AT, ROOM_TEMPLE_BALCONY, 0
    DB G_END, 0, 0

rem --- Pattern-response fallback (legacy VERB_PATTERN_INDEX) ---
rem Requires ACT_PARSE_INPUT to also write a legacy pattern index (0 if none).
FLAG_VERB_PATTERN_INDEX = 24

GUARD_PATTERN_RESPONSE:
    DB G_FLAG_NE, FLAG_VERB_PATTERN_INDEX, 0
    DB G_FLAG_EQ, FLAG_CURRENT_VERB, VERB_NONE
    DB G_END, 0, 0

rem --- On-enter / dynamic state ---
GUARD_AT_BRIDGE_MID:
    DB G_AT, ROOM_BRIDGE_MID, 0
    DB G_END, 0, 0

GUARD_AT_FOREST_CLEARING:
    DB G_AT, ROOM_FOREST_CLEARING, 0
    DB G_END, 0, 0

GUARD_AT_WATERFALL_BASE:
    DB G_AT, ROOM_WATERFALL_BASE, 0
    DB G_END, 0, 0

GUARD_AT_TEMPLE:
    DB G_AT, ROOM_TEMPLE, 0
    DB G_END, 0, 0

GUARD_AT_DRAWBRIDGE:
    DB G_AT, ROOM_DRAWBRIDGE, 0
    DB G_END, 0, 0

GUARD_GRILL_NOT_IN_TINY_CELL:
    DB 0x80 + G_ENT_AT_ROOM, OBJ_GRILL, ROOM_TINY_CELL
    DB G_END, 0, 0

GUARD_BAT_PRESENT:
    DB G_ENT_AT_PLAYER, ENT_BAT, 0
    DB G_END, 0, 0

rem --- Describe ---
GUARD_HOSTILE_ATTACKABLE:
    DB G_FLAG_NE, FLAG_HOSTILE_CREATURE_INDEX, 0
    DB G_FLAG_NE, FLAG_HOSTILE_CREATURE_INDEX, ENT_BAT
    DB G_FLAG_NE, FLAG_CURRENT_OBJECT, OBJ_SWORD
    DB G_END, 0, 0

GUARD_BRIGHT_BY_ROOM:
    DB G_ROOM_LT, ROOM_DARK_CAVERN_A, 0
    DB G_END, 0, 0

GUARD_BRIGHT_BY_CANDLE:
    DB G_FLAG_EQ, FLAG_CANDLE_LIT, 1
    DB G_ENT_VISIBLE, OBJ_CANDLE, 0
    DB G_END, 0, 0

rem ---------------------------------------------------------
rem  Concrete guard list examples (fixed arity)
rem ---------------------------------------------------------
rem Darkness:
rem   "room < ROOM_DARK_CAVERN_A OR (candle lit AND candle visible)"
rem
rem   Rule 1 (bright by room):
rem     GUARDS:
rem       DB G_ROOM_LT, ROOM_DARK_CAVERN_A, 0
rem       DB G_END, 0, 0
rem     ACTION: ACT_PRINT_ROOM_DESCRIPTION_PTRS
rem
rem   Rule 2 (bright by candle):
rem     GUARDS:
rem       DB G_FLAG_EQ, FLAG_CANDLE_LIT, 1
rem       DB G_ENT_VISIBLE, OBJ_CANDLE, 0
rem       DB G_END, 0, 0
rem     ACTION: ACT_PRINT_ROOM_DESCRIPTION_PTRS
rem
rem   Rule 3 (fallback):
rem     GUARDS:
rem       DB G_END, 0, 0
rem     ACTION: ACT_PRINT_DARKNESS_MESSAGE
rem
rem Hostile attack gating (legacy: "if hostile and not bat and current object != sword"):
rem   GUARDS:
rem     DB G_FLAG_NE, FLAG_HOSTILE_CREATURE_INDEX, 0
rem     DB G_FLAG_NE, FLAG_HOSTILE_CREATURE_INDEX, ENT_BAT
rem     DB G_FLAG_NE, FLAG_CURRENT_OBJECT, OBJ_SWORD
rem     DB G_END, 0, 0
rem   ACTION: ACT_MONSTER_ATTACK_AND_KILL
rem
rem Object visibility gate (legacy: "Where? I can't see it."):
rem   GUARDS:
rem     DB G_FLAG_NE, FLAG_CURRENT_OBJECT, 0
rem     DB 0x80+G_ENT_VISIBLE, FLAG_CURRENT_OBJECT, 0    rem NOT visible
rem     DB G_END, 0, 0
rem   ACTION: ACT_PRINT_WHERE_I_CANT_SEE_IT
rem
rem ---------------------------------------------------------
rem  Legacy label -> phase mapping (conversion checklist)
rem ---------------------------------------------------------
rem Input loop:
rem   GET_PLAYER_INPUT + PARSE_COMMAND_ENTRY
rem     -> ACT_READ_INPUT_AND_NORMALIZE, ACT_PARSE_INPUT, ACT_UPDATE_HOSTILE_CREATURE_INDEX
rem     -> run PHASE_ON_COMMAND
rem
rem After movement:
rem   "bridge mid", "hut flag", "waterfall/temple water exit", "grill gate", "drawbridge state"
rem     -> PHASE_ON_ENTER rules + ACT_PATCH_DYNAMIC_EXITS (replaces UPDATE_DYNAMIC_EXITS_SUB)
rem
rem Description:
rem   DESCRIBE_CURRENT_LOCATION + PRINT_ROOM_DESCRIPTION + LIST_ROOM_OBJECTS_AND_CREATURES
rem     -> PHASE_DESCRIBE + ACT_PRINT_ROOM_EXTRAS + ACT_LIST_VISIBLE_ENTITIES + ACT_PROMPT
rem
rem Quit:
rem   QUIT_GAME + PRINT_RANKING_SUB
rem     -> ACT_QUIT_AND_SCORE
rem
rem ---------------------------------------------------------
rem  PHASE_ON_COMMAND: intended rule order (minimal set)
rem ---------------------------------------------------------
rem  1) SPECIAL_WORD = LOOK  -> ACT_FORCE_REDESCRIBE
rem  2) SPECIAL_WORD = LIST  -> ACT_PRINT_INVENTORY
rem  3) SPECIAL_WORD = QUIT  -> ACT_QUIT_AND_SCORE
rem  4) SPECIAL_WORD = GALAR -> ACT_TELEPORT_TO_CAVE_ENTRY (then PHASE_ON_ENTER + PHASE_DESCRIBE)
rem  5) SPECIAL_WORD = APE   -> ACT_OPEN_CRYPT_SECRET_EXIT + ACT_PATCH_DYNAMIC_EXITS (then PHASE_DESCRIBE)
rem  6) CURRENT_DIR != 0xFF  -> ACT_RESOLVE_MOVEMENT
rem  7) CURRENT_OBJECT != 0 and NOT visible -> ACT_PRINT_WHERE_I_CANT_SEE_IT
rem  8) VERB = GET           -> ACT_TRY_GET_CURRENT_OBJECT
rem  9) VERB = DROP          -> ACT_DROP_CURRENT_OBJECT
rem 10) VERB = USE + OBJ=KEY   -> ACT_USE_KEY (rule-split by location if preferred)
rem 11) VERB = USE + OBJ=SWORD -> ACT_SWORD_COMBAT or ACT_PRINT_NOTHING_TO_KILL (guard-split)
rem 12) VERB = USE + OBJ=CANDLE-> ACT_USE_BOMB (matches pseudo3 wiring)
rem 13) VERB = USE + OBJ=ROPE  -> ACT_USE_ROPE
rem 14) fallback             -> ACT_PRINT_EH
rem
rem ---------------------------------------------------------
rem  PHASE_ON_ENTER: intended rule order
rem ---------------------------------------------------------
rem  1) at ROOM_BRIDGE_MID        -> set FLAG_BRIDGE_CONDITION=EXIT_FATAL; ACT_PATCH_DYNAMIC_EXITS
rem  2) at ROOM_FOREST_CLEARING   -> set FLAG_HUT_VISITED=1
rem  3) at ROOM_WATERFALL_BASE    -> set FLAG_WATER_EXIT_LOCATION=43; patch
rem  4) at ROOM_TEMPLE            -> set FLAG_WATER_EXIT_LOCATION=0; patch
rem  5) grill NOT at ROOM_TINY_CELL -> set FLAG_GATE_DESTINATION=39; patch
rem  6) at ROOM_DRAWBRIDGE        -> set FLAG_DRAWBRIDGE_STATE=ROOM_DRAWBRIDGE; patch
rem  7) otherwise                 -> no-op
rem
rem Note (legacy parity):
rem   - WATER_EXIT_LOCATION is explicitly reset at ROOM_TEMPLE; we match that.
rem   - In the legacy flow, DRAWBRIDGE_STATE, TELEPORT_DESTINATION, SECRET_EXIT_LOCATION are only set
rem     and are not explicitly cleared.
rem   - In the executable data-driven engine below, we *do* include clear-on-leave rules for:
rem       - DRAWBRIDGE_STATE (clear when not at ROOM_DRAWBRIDGE)
rem       - TELEPORT_DESTINATION (clear when not at ROOM_OAK_DOOR)
rem       - SECRET_EXIT_LOCATION (clear when not at ROOM_CRYPT)
rem     If you want strict legacy parity, remove those clear rules/actions.
rem
rem Set/clear ordering rule:
rem   For any “set” action guarded by `G_AT room`, ensure it appears before the corresponding
rem   “clear” action guarded by `NOT G_AT room`, otherwise the clear will win and the state
rem   will never stick.
rem ---------------------------------------------------------
rem  Interpreter pseudocode (Appendix B semantics)
rem ---------------------------------------------------------
rem run_phase(phaseId):
rem   for rule in RULE_TABLE:
rem     if rule.phaseId != phaseId: continue
rem     if eval_guard_list(rule.guardPtr) == TRUE:
rem       call rule.actionPtr
rem       return
rem
rem eval_guard_list(ptr):
rem   mode = AND
rem   acc  = TRUE
rem   loop:
rem     opcode = *ptr++ ; opA = *ptr++ ; opB = *ptr++
rem     if opcode == G_END: return acc
rem     if opcode == G_AND: mode = AND: continue
rem     if opcode == G_OR:  mode = OR:  continue
rem
rem     notBit = opcode & 0x80
rem     op     = opcode & 0x7F
rem     res    = eval_atomic_guard(op, opA, opB)
rem     if notBit: res = NOT res
rem
rem     if mode == AND:
rem       acc = acc AND res
rem       if acc == FALSE: return FALSE
rem     else:
rem       acc = acc OR res
rem       if acc == TRUE: return TRUE
rem
rem =========================================================
rem  Data-Driven Engine (executable pseudo)
rem =========================================================

rem This is the same game logic as the legacy appendix, but expressed as:
rem   - flat state arrays
rem   - phase-based rule evaluation
rem   - fixed-arity guard lists
rem   - action dispatch by action-id
rem
rem NOTE: This is “code” in the pseudo3 dialect. The legacy listing remains as a
rem reference appendix only.


rem ---------------------------------------------------------
rem Constants (copied from legacy so this section is standalone)
rem ---------------------------------------------------------

ROOM_MAX = 54
DIR_NORTH_STR=0: DIR_SOUTH_STR=1: DIR_WEST_STR=2: DIR_EAST_STR=3
EXIT_NONE = 0
EXIT_FATAL = 128

rem Rooms 1..54
ROOM_DARK_ROOM = 1
ROOM_FOREST_CLEARING = 2
ROOM_DARK_FOREST = 3
ROOM_CLOVER_FIELD = 4
ROOM_RIVER_CLIFF = 5
ROOM_RIVER_BANK = 6
ROOM_CRATER_EDGE = 7
ROOM_RIVER_OUTCROP = 8
ROOM_MT_YMIR_SLOPE = 9
ROOM_BRIDGE_NORTH_ANCHOR = 10
ROOM_BRIDGE_MID = 11
ROOM_BRIDGE_SOUTH_ANCHOR = 12
ROOM_MUSHROOM_ROCK = 13
ROOM_CAVE_ENTRANCE_CLEARING = 14
ROOM_CLIFF_FACE = 15
ROOM_CAVE_ENTRY = 16
ROOM_DEAD_END_INSCRIPTION = 17
ROOM_DARK_CAVERN_A = 18
ROOM_TREASURE_ROOM = 19
ROOM_OAK_DOOR = 20
ROOM_DARK_CAVERN_B = 21
ROOM_WIND_CORRIDOR = 22
ROOM_TORTURE_CHAMBER = 23
ROOM_NORTH_SOUTH_TUNNEL = 24
ROOM_DARK_CAVERN_C = 25
ROOM_ROUND_ROOM = 26
ROOM_LEDGE_OVER_RIVER = 27
ROOM_TEMPLE_BALCONY = 28
ROOM_DARK_CAVERN_D = 29
ROOM_DARK_CAVERN_E = 30
ROOM_DARK_CAVERN_F = 31
ROOM_DARK_CAVERN_G = 32
ROOM_BAT_CAVE = 33
ROOM_DARK_CAVERN_H = 34
ROOM_TEMPLE = 35
ROOM_DARK_CAVERN_I = 36
ROOM_CRYPT = 37
ROOM_TINY_CELL = 38
ROOM_DARK_CAVERN_J = 39
ROOM_LEDGE_WATERFALL_IN = 40
ROOM_DRAIN_A = 41
ROOM_DRAIN_B = 42
ROOM_DRAIN_C = 43
ROOM_DRAIN_D = 44
ROOM_WATERFALL_BASE = 45
ROOM_DARK_CAVERN_K = 46
ROOM_STONE_STAIRCASE = 47
ROOM_CASTLE_LEDGE = 48
ROOM_DRAWBRIDGE = 49
ROOM_CASTLE_COURTYARD = 50
ROOM_POWDER_MAG = 51
ROOM_EAST_RIVERBANK = 52
ROOM_WOODEN_BRIDGE = 53
ROOM_RIVER_CONDUIT = 54

rem Entities 1..24 (1–6 creatures, 7–24 objects)
ENT_WIZARD=1: ENT_DEMON=2: ENT_TROLL=3: ENT_DRAGON=4: ENT_BAT=5: ENT_DWARF=6
OBJ_BOMB=9: OBJ_KEY=19: OBJ_SWORD=20: OBJ_CANDLE=21: OBJ_ROPE=22: OBJ_GRILL=24

ENT_LOC_CARRIED = 255
ENT_LOC_REMOVED = 0

PHASE_DESCRIBE=0: PHASE_ON_ENTER=1: PHASE_ON_COMMAND=2


rem ---------------------------------------------------------
rem Parser enums (byte values)
rem ---------------------------------------------------------

SPECIAL_NONE  = 0
SPECIAL_LOOK  = 1
SPECIAL_LIST  = 2
SPECIAL_QUIT  = 3
SPECIAL_GALAR = 4
SPECIAL_APE   = 5

VERB_NONE = 0
VERB_GET  = 1
VERB_DROP = 2
VERB_USE  = 3


rem ---------------------------------------------------------
rem Runtime state
rem ---------------------------------------------------------

PLAYER_ALIVE = 1
PLAYER_LOCATION = ROOM_DARK_ROOM
TURN_COUNTER = 0
dim ENTITY_LOCATION(24)
dim FLAGS(64)

NULL = 0

rem Tables (reused from legacy DATA TABLES section later in this file)
dim MOVEMENT_TABLE(ROOM_MAX,3)
dim ROOM_DESC1_PTR(ROOM_MAX), ROOM_DESC2_PTR(ROOM_MAX)
dim OBJECT_NAME_ADJ(24), OBJECT_NAME_NOUN(24)
dim MONSTER_ADJ(6), MONSTER_NOUN(6)
dim VERB_PATTERN(16)
dim DIR_WORD_INDEX(4)
dim OBJDESC1(24), OBJDESC2(24)

FLAG_HOSTILE_CREATURE_INDEX = 0
FLAG_CANDLE_LIT            = 1
FLAG_HUT_VISITED           = 2
FLAG_BRIDGE_CONDITION      = 10
FLAG_DRAWBRIDGE_STATE      = 11
FLAG_WATER_EXIT_LOCATION   = 12
FLAG_GATE_DESTINATION      = 13
FLAG_TELEPORT_DESTINATION  = 14
FLAG_SECRET_EXIT_LOCATION  = 15
FLAG_CURRENT_VERB          = 20
FLAG_CURRENT_DIR           = 21
FLAG_CURRENT_OBJECT        = 22
FLAG_SPECIAL_WORD          = 23
FLAG_VERB_PATTERN_INDEX    = 24
FLAG_SWORD_SWING_COUNT     = 30
FLAG_SCORE                 = 31
FLAG_PLAYER_MOVED          = 40


rem ---------------------------------------------------------
rem Guard opcodes (subset)
rem ---------------------------------------------------------

G_END=0
G_AND=1
G_OR=2
G_AT=3
G_ROOM_LT=4
G_FLAG_EQ=5
G_FLAG_NE=6
G_ENT_AT_ROOM=7
G_ENT_AT_PLAYER=8
G_ENT_CARRIED=9
G_ENT_VISIBLE=10
G_ENT_VISIBLE_CURRENT=11


rem ---------------------------------------------------------
rem Action IDs (dispatch since indirect GOSUB isn't available)
rem ---------------------------------------------------------

ACT_FORCE_REDESCRIBE = 1
ACT_PRINT_INVENTORY = 2
ACT_QUIT_AND_SCORE = 3
ACT_TELEPORT_TO_CAVE_ENTRY = 4
ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH = 5
ACT_RESOLVE_MOVEMENT = 6
ACT_PRINT_EH = 7
ACT_PRINT_WHERE_I_CANT_SEE_IT = 8
ACT_TRY_GET_CURRENT_OBJECT = 9
ACT_DROP_CURRENT_OBJECT = 10
ACT_PRINT_IT_WONT_OPEN = 11
ACT_USE_KEY_FOREST = 12
ACT_USE_KEY_TEMPLE = 13
ACT_PRINT_NOTHING_TO_KILL = 14
ACT_SWORD_COMBAT = 15
ACT_USE_BOMB = 16
ACT_PRINT_TOO_DANGEROUS = 17
ACT_USE_ROPE = 18
ACT_PRINT_PATTERN_RESPONSE = 19
ACT_SET_BRIDGE_FATAL_AND_PATCH = 20
ACT_SET_HUT_VISITED = 21
ACT_ENABLE_WATER_EXIT_AND_PATCH = 22
ACT_DISABLE_WATER_EXIT_AND_PATCH = 23
ACT_SET_GATE_DEST_AND_PATCH = 24
ACT_SET_DRAWBRIDGE_AND_PATCH = 25
ACT_BAT_CARRY = 26
ACT_NOOP = 27
ACT_MONSTER_ATTACK_AND_KILL = 28
ACT_DESCRIBE_LIT = 29
ACT_DESCRIBE_DARK = 30
ACT_CLEAR_GATE_DEST_AND_PATCH = 31
ACT_CLEAR_DRAWBRIDGE_AND_PATCH = 32
ACT_CLEAR_TELEPORT_DEST_AND_PATCH = 33
ACT_CLEAR_SECRET_EXIT_AND_PATCH = 34


rem ---------------------------------------------------------
rem Rules and guards (tables)
rem ---------------------------------------------------------

RULE_COUNT = 0
dim RULE_PHASE(128)
dim RULE_GPTR(128)
dim RULE_ACT(128)

dim GUARD_DATA(2048)

gosub BUILD_RULE_TABLE_SUB


rem ---------------------------------------------------------
rem Program entry (data-driven)
rem ---------------------------------------------------------

DATA_DRIVEN_START:
    gosub INIT_STATE_SUB

MAIN_LOOP:
    if PLAYER_ALIVE = 0 then
        gosub ACT_QUIT_AND_SCORE_SUB
        end
    end if

    gosub READ_INPUT_AND_PARSE_SUB
    gosub UPDATE_HOSTILE_SUB

    CURRENT_PHASE = PHASE_ON_COMMAND
    gosub RUN_PHASE_SUB

    if FLAGS(FLAG_PLAYER_MOVED) = 1 then
        FLAGS(FLAG_PLAYER_MOVED) = 0
        CURRENT_PHASE = PHASE_ON_ENTER
        gosub RUN_PHASE_SUB
    end if

    CURRENT_PHASE = PHASE_DESCRIBE
    gosub RUN_PHASE_SUB

    goto MAIN_LOOP


rem ---------------------------------------------------------
rem Interpreter (rule evaluation + fixed-arity guards)
rem ---------------------------------------------------------

RUN_PHASE_SUB:
    for RULE_I = 0 to RULE_COUNT-1
        if RULE_PHASE(RULE_I) <> CURRENT_PHASE then
            goto NEXT_RULE
        end if
        GUARD_PTR = RULE_GPTR(RULE_I)
        gosub EVAL_GUARDS_SUB
        if GUARDS_PASS = 1 then
            ACTION_ID = RULE_ACT(RULE_I)
            gosub DISPATCH_ACTION_SUB
            return
        end if
NEXT_RULE:
    next RULE_I
    return

EVAL_GUARDS_SUB:
    GUARDS_PASS = 0
    BOOL_MODE = G_AND
    ACC = 1
EVAL_LOOP:
    OPCODE = GUARD_DATA(GUARD_PTR): GUARD_PTR = GUARD_PTR + 1
    OPA    = GUARD_DATA(GUARD_PTR): GUARD_PTR = GUARD_PTR + 1
    OPB    = GUARD_DATA(GUARD_PTR): GUARD_PTR = GUARD_PTR + 1

    if OPCODE = G_END then
        GUARDS_PASS = ACC
        return
    end if
    if OPCODE = G_AND then
        BOOL_MODE = G_AND
        goto EVAL_LOOP
    end if
    if OPCODE = G_OR then
        BOOL_MODE = G_OR
        goto EVAL_LOOP
    end if

    NOTBIT = 0
    if OPCODE >= 128 then
        NOTBIT = 1
        OPCODE = OPCODE - 128
    end if

    gosub EVAL_ATOMIC_GUARD_SUB
    RES = ATOMIC_RESULT
    if NOTBIT = 1 then
        if RES = 1 then RES = 0 else RES = 1
    end if

    if BOOL_MODE = G_AND then
        if ACC = 1 and RES = 1 then
            ACC = 1
        else
            GUARDS_PASS = 0
            return
        end if
    else
        if ACC = 1 or RES = 1 then
            GUARDS_PASS = 1
            return
        end if
    end if

    goto EVAL_LOOP

EVAL_ATOMIC_GUARD_SUB:
    ATOMIC_RESULT = 0
    if OPCODE = G_AT then
        if PLAYER_LOCATION = OPA then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_ROOM_LT then
        if PLAYER_LOCATION < OPA then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_FLAG_EQ then
        if FLAGS(OPA) = OPB then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_FLAG_NE then
        if FLAGS(OPA) <> OPB then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_ENT_AT_ROOM then
        if ENTITY_LOCATION(OPA) = OPB then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_ENT_AT_PLAYER then
        if ENTITY_LOCATION(OPA) = PLAYER_LOCATION then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_ENT_CARRIED then
        if ENTITY_LOCATION(OPA) = ENT_LOC_CARRIED then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_ENT_VISIBLE then
        if ENTITY_LOCATION(OPA) = ENT_LOC_CARRIED or ENTITY_LOCATION(OPA) = PLAYER_LOCATION then ATOMIC_RESULT = 1
        return
    end if
    if OPCODE = G_ENT_VISIBLE_CURRENT then
        ENT = FLAGS(OPA)
        if ENT <> 0 then
            if ENTITY_LOCATION(ENT) = ENT_LOC_CARRIED or ENTITY_LOCATION(ENT) = PLAYER_LOCATION then ATOMIC_RESULT = 1
        end if
        return
    end if
    return


DISPATCH_ACTION_SUB:
    select case ACTION_ID
        case ACT_FORCE_REDESCRIBE: gosub ACT_FORCE_REDESCRIBE_SUB
        case ACT_PRINT_INVENTORY: gosub ACT_PRINT_INVENTORY_SUB
        case ACT_QUIT_AND_SCORE: gosub ACT_QUIT_AND_SCORE_SUB
        case ACT_TELEPORT_TO_CAVE_ENTRY: gosub ACT_TELEPORT_TO_CAVE_ENTRY_SUB
        case ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH: gosub ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH_SUB
        case ACT_RESOLVE_MOVEMENT: gosub ACT_RESOLVE_MOVEMENT_SUB
        case ACT_PRINT_EH: gosub ACT_PRINT_EH_SUB
        case ACT_PRINT_WHERE_I_CANT_SEE_IT: gosub ACT_PRINT_WHERE_I_CANT_SEE_IT_SUB
        case ACT_TRY_GET_CURRENT_OBJECT: gosub ACT_TRY_GET_CURRENT_OBJECT_SUB
        case ACT_DROP_CURRENT_OBJECT: gosub ACT_DROP_CURRENT_OBJECT_SUB
        case ACT_PRINT_IT_WONT_OPEN: gosub ACT_PRINT_IT_WONT_OPEN_SUB
        case ACT_USE_KEY_FOREST: gosub ACT_USE_KEY_FOREST_SUB
        case ACT_USE_KEY_TEMPLE: gosub ACT_USE_KEY_TEMPLE_SUB
        case ACT_PRINT_NOTHING_TO_KILL: gosub ACT_PRINT_NOTHING_TO_KILL_SUB
        case ACT_SWORD_COMBAT: gosub ACT_SWORD_COMBAT_SUB
        case ACT_USE_BOMB: gosub ACT_USE_BOMB_SUB
        case ACT_PRINT_TOO_DANGEROUS: gosub ACT_PRINT_TOO_DANGEROUS_SUB
        case ACT_USE_ROPE: gosub ACT_USE_ROPE_SUB
        case ACT_PRINT_PATTERN_RESPONSE: gosub ACT_PRINT_PATTERN_RESPONSE_SUB
        case ACT_SET_BRIDGE_FATAL_AND_PATCH: gosub ACT_SET_BRIDGE_FATAL_AND_PATCH_SUB
        case ACT_SET_HUT_VISITED: gosub ACT_SET_HUT_VISITED_SUB
        case ACT_ENABLE_WATER_EXIT_AND_PATCH: gosub ACT_ENABLE_WATER_EXIT_AND_PATCH_SUB
        case ACT_DISABLE_WATER_EXIT_AND_PATCH: gosub ACT_DISABLE_WATER_EXIT_AND_PATCH_SUB
        case ACT_SET_GATE_DEST_AND_PATCH: gosub ACT_SET_GATE_DEST_AND_PATCH_SUB
        case ACT_CLEAR_GATE_DEST_AND_PATCH: gosub ACT_CLEAR_GATE_DEST_AND_PATCH_SUB
        case ACT_SET_DRAWBRIDGE_AND_PATCH: gosub ACT_SET_DRAWBRIDGE_AND_PATCH_SUB
        case ACT_CLEAR_DRAWBRIDGE_AND_PATCH: gosub ACT_CLEAR_DRAWBRIDGE_AND_PATCH_SUB
        case ACT_CLEAR_TELEPORT_DEST_AND_PATCH: gosub ACT_CLEAR_TELEPORT_DEST_AND_PATCH_SUB
        case ACT_CLEAR_SECRET_EXIT_AND_PATCH: gosub ACT_CLEAR_SECRET_EXIT_AND_PATCH_SUB
        case ACT_BAT_CARRY: gosub ACT_BAT_CARRY_SUB
        case ACT_NOOP: gosub ACT_NOOP_SUB
        case ACT_MONSTER_ATTACK_AND_KILL: gosub ACT_MONSTER_ATTACK_AND_KILL_SUB
        case ACT_DESCRIBE_LIT: gosub ACT_DESCRIBE_LIT_SUB
        case ACT_DESCRIBE_DARK: gosub ACT_DESCRIBE_DARK_SUB
    end select
    return


rem ---------------------------------------------------------
rem Build tables
rem ---------------------------------------------------------

ADD_RULE_SUB:
    RULE_PHASE(RULE_COUNT) = RULE_PHASE_TMP
    RULE_GPTR(RULE_COUNT)  = RULE_GPTR_TMP
    RULE_ACT(RULE_COUNT)   = RULE_ACT_TMP
    RULE_COUNT = RULE_COUNT + 1
    return

BUILD_RULE_TABLE_SUB:
    gosub BUILD_GUARDS_SUB

    rem PHASE_ON_COMMAND
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_SPECIAL_LOOK: RULE_ACT_TMP=ACT_FORCE_REDESCRIBE: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_SPECIAL_LIST: RULE_ACT_TMP=ACT_PRINT_INVENTORY: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_SPECIAL_QUIT: RULE_ACT_TMP=ACT_QUIT_AND_SCORE: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_SPECIAL_GALAR: RULE_ACT_TMP=ACT_TELEPORT_TO_CAVE_ENTRY: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_SPECIAL_APE: RULE_ACT_TMP=ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_HAS_DIR: RULE_ACT_TMP=ACT_RESOLVE_MOVEMENT: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_NO_OBJECT: RULE_ACT_TMP=ACT_PRINT_EH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_OBJ_NOT_VISIBLE: RULE_ACT_TMP=ACT_PRINT_WHERE_I_CANT_SEE_IT: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_VERB_GET: RULE_ACT_TMP=ACT_TRY_GET_CURRENT_OBJECT: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_VERB_DROP: RULE_ACT_TMP=ACT_DROP_CURRENT_OBJECT: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_KEY_BAD: RULE_ACT_TMP=ACT_PRINT_IT_WONT_OPEN: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_KEY_FOREST: RULE_ACT_TMP=ACT_USE_KEY_FOREST: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_KEY_TEMPLE: RULE_ACT_TMP=ACT_USE_KEY_TEMPLE: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_SWORD_NOHOST: RULE_ACT_TMP=ACT_PRINT_NOTHING_TO_KILL: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_SWORD_HOST: RULE_ACT_TMP=ACT_SWORD_COMBAT: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_BOMB: RULE_ACT_TMP=ACT_USE_BOMB: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_ROPE_BAD: RULE_ACT_TMP=ACT_PRINT_TOO_DANGEROUS: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_USE_ROPE_OK: RULE_ACT_TMP=ACT_USE_ROPE: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_PATTERN_RESP: RULE_ACT_TMP=ACT_PRINT_PATTERN_RESPONSE: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_COMMAND: RULE_GPTR_TMP=GP_ALWAYS: RULE_ACT_TMP=ACT_PRINT_EH: gosub ADD_RULE_SUB

    rem PHASE_ON_ENTER
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_AT_BRIDGE_MID: RULE_ACT_TMP=ACT_SET_BRIDGE_FATAL_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_AT_FOREST_CLEARING: RULE_ACT_TMP=ACT_SET_HUT_VISITED: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_AT_WATERFALL_BASE: RULE_ACT_TMP=ACT_ENABLE_WATER_EXIT_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_AT_TEMPLE: RULE_ACT_TMP=ACT_DISABLE_WATER_EXIT_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_GRILL_NOT_TINY: RULE_ACT_TMP=ACT_SET_GATE_DEST_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_GRILL_IN_TINY: RULE_ACT_TMP=ACT_CLEAR_GATE_DEST_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_AT_DRAWBRIDGE: RULE_ACT_TMP=ACT_SET_DRAWBRIDGE_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_NOT_AT_DRAWBRIDGE: RULE_ACT_TMP=ACT_CLEAR_DRAWBRIDGE_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_AT_OAK_DOOR: RULE_ACT_TMP=ACT_NOOP: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_NOT_AT_OAK_DOOR: RULE_ACT_TMP=ACT_CLEAR_TELEPORT_DEST_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_AT_CRYPT: RULE_ACT_TMP=ACT_NOOP: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_NOT_AT_CRYPT: RULE_ACT_TMP=ACT_CLEAR_SECRET_EXIT_AND_PATCH: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_BAT_PRESENT: RULE_ACT_TMP=ACT_BAT_CARRY: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_ON_ENTER: RULE_GPTR_TMP=GP_ALWAYS: RULE_ACT_TMP=ACT_NOOP: gosub ADD_RULE_SUB

    rem PHASE_DESCRIBE
    RULE_PHASE_TMP=PHASE_DESCRIBE: RULE_GPTR_TMP=GP_HOSTILE_ATTACK: RULE_ACT_TMP=ACT_MONSTER_ATTACK_AND_KILL: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_DESCRIBE: RULE_GPTR_TMP=GP_BRIGHT_ROOM: RULE_ACT_TMP=ACT_DESCRIBE_LIT: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_DESCRIBE: RULE_GPTR_TMP=GP_BRIGHT_CANDLE: RULE_ACT_TMP=ACT_DESCRIBE_LIT: gosub ADD_RULE_SUB
    RULE_PHASE_TMP=PHASE_DESCRIBE: RULE_GPTR_TMP=GP_ALWAYS: RULE_ACT_TMP=ACT_DESCRIBE_DARK: gosub ADD_RULE_SUB
    return

BUILD_GUARDS_SUB:
    GD = 0

    GP_ALWAYS = GD: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_SPECIAL_LOOK = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_SPECIAL_WORD:GUARD_DATA(GD+2)=SPECIAL_LOOK: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_SPECIAL_LIST = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_SPECIAL_WORD:GUARD_DATA(GD+2)=SPECIAL_LIST: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_SPECIAL_QUIT = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_SPECIAL_WORD:GUARD_DATA(GD+2)=SPECIAL_QUIT: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_SPECIAL_GALAR = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_SPECIAL_WORD:GUARD_DATA(GD+2)=SPECIAL_GALAR: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_SPECIAL_APE = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_SPECIAL_WORD:GUARD_DATA(GD+2)=SPECIAL_APE: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_HAS_DIR = GD: GUARD_DATA(GD)=G_FLAG_NE:GUARD_DATA(GD+1)=FLAG_CURRENT_DIR:GUARD_DATA(GD+2)=255: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_NO_OBJECT = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_OBJ_NOT_VISIBLE = GD: GUARD_DATA(GD)=G_FLAG_NE:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=128+G_ENT_VISIBLE_CURRENT:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_VERB_GET = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_GET: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_VERB_DROP = GD: GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_DROP: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_KEY_BAD = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_KEY: GD=GD+3
    GUARD_DATA(GD)=128+G_AT:GUARD_DATA(GD+1)=ROOM_FOREST_CLEARING:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=128+G_AT:GUARD_DATA(GD+1)=ROOM_TEMPLE:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_KEY_FOREST = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_KEY: GD=GD+3
    GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_FOREST_CLEARING:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_KEY_TEMPLE = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_KEY: GD=GD+3
    GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_TEMPLE:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_SWORD_NOHOST = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_SWORD: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_HOSTILE_CREATURE_INDEX:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_SWORD_HOST = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_SWORD: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_NE:GUARD_DATA(GD+1)=FLAG_HOSTILE_CREATURE_INDEX:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_BOMB = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_CANDLE: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_ROPE_BAD = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_ROPE: GD=GD+3
    GUARD_DATA(GD)=128+G_AT:GUARD_DATA(GD+1)=ROOM_TEMPLE_BALCONY:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_USE_ROPE_OK = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_USE: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_ROPE: GD=GD+3
    GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_TEMPLE_BALCONY:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_PATTERN_RESP = GD
    GUARD_DATA(GD)=G_FLAG_NE:GUARD_DATA(GD+1)=FLAG_VERB_PATTERN_INDEX:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CURRENT_VERB:GUARD_DATA(GD+2)=VERB_NONE: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_AT_BRIDGE_MID = GD: GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_BRIDGE_MID:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_AT_FOREST_CLEARING = GD: GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_FOREST_CLEARING:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_AT_WATERFALL_BASE = GD: GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_WATERFALL_BASE:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_AT_TEMPLE = GD: GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_TEMPLE:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_AT_DRAWBRIDGE = GD: GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_DRAWBRIDGE:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_NOT_AT_DRAWBRIDGE = GD: GUARD_DATA(GD)=128+G_AT:GUARD_DATA(GD+1)=ROOM_DRAWBRIDGE:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_AT_OAK_DOOR = GD: GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_OAK_DOOR:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_NOT_AT_OAK_DOOR = GD: GUARD_DATA(GD)=128+G_AT:GUARD_DATA(GD+1)=ROOM_OAK_DOOR:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_AT_CRYPT = GD: GUARD_DATA(GD)=G_AT:GUARD_DATA(GD+1)=ROOM_CRYPT:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_NOT_AT_CRYPT = GD: GUARD_DATA(GD)=128+G_AT:GUARD_DATA(GD+1)=ROOM_CRYPT:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_GRILL_NOT_TINY = GD: GUARD_DATA(GD)=128+G_ENT_AT_ROOM:GUARD_DATA(GD+1)=OBJ_GRILL:GUARD_DATA(GD+2)=ROOM_TINY_CELL: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_GRILL_IN_TINY = GD: GUARD_DATA(GD)=G_ENT_AT_ROOM:GUARD_DATA(GD+1)=OBJ_GRILL:GUARD_DATA(GD+2)=ROOM_TINY_CELL: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_BAT_PRESENT = GD: GUARD_DATA(GD)=G_ENT_AT_PLAYER:GUARD_DATA(GD+1)=ENT_BAT:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_HOSTILE_ATTACK = GD
    GUARD_DATA(GD)=G_FLAG_NE:GUARD_DATA(GD+1)=FLAG_HOSTILE_CREATURE_INDEX:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_NE:GUARD_DATA(GD+1)=FLAG_HOSTILE_CREATURE_INDEX:GUARD_DATA(GD+2)=ENT_BAT: GD=GD+3
    GUARD_DATA(GD)=G_FLAG_NE:GUARD_DATA(GD+1)=FLAG_CURRENT_OBJECT:GUARD_DATA(GD+2)=OBJ_SWORD: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3

    GP_BRIGHT_ROOM = GD: GUARD_DATA(GD)=G_ROOM_LT:GUARD_DATA(GD+1)=ROOM_DARK_CAVERN_A:GUARD_DATA(GD+2)=0: GD=GD+3: GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    GP_BRIGHT_CANDLE = GD
    GUARD_DATA(GD)=G_FLAG_EQ:GUARD_DATA(GD+1)=FLAG_CANDLE_LIT:GUARD_DATA(GD+2)=1: GD=GD+3
    GUARD_DATA(GD)=G_ENT_VISIBLE:GUARD_DATA(GD+1)=OBJ_CANDLE:GUARD_DATA(GD+2)=0: GD=GD+3
    GUARD_DATA(GD)=G_END:GUARD_DATA(GD+1)=0:GUARD_DATA(GD+2)=0: GD=GD+3
    return


rem ---------------------------------------------------------
rem Action implementations (stubs)
rem ---------------------------------------------------------
rem These are intentionally minimal here; the conversion work is in the tables+guards.

INIT_STATE_SUB:
    rem Load static tables from DATA TABLES section
    MOVEMENT_TABLE = MOVEMENT_TABLE_DATA
    ROOM_DESC1_PTR = ROOM_DESC1_PTR
    ROOM_DESC2_PTR = ROOM_DESC2_PTR
    OBJECT_NAME_ADJ = OBJECT_NAME_ADJ_DATA
    OBJECT_NAME_NOUN = OBJECT_NAME_NOUN_DATA
    MONSTER_ADJ = MONSTER_ADJ_DATA
    MONSTER_NOUN = MONSTER_NOUN_DATA
    VERB_PATTERN = VERB_PATTERN_DATA
    DIR_WORD_INDEX = DIR_WORD_INDEX_DATA
    OBJDESC1 = OBJDESC1_DATA
    OBJDESC2 = OBJDESC2_DATA

    rem Initialize entity locations from legacy object table
    ENTITY_LOCATION = OBJECT_LOCATION_DATA

    PLAYER_ALIVE = 1
    PLAYER_LOCATION = ROOM_DARK_ROOM
    TURN_COUNTER = 0
    FLAGS(FLAG_PLAYER_MOVED) = 0

    rem Dynamic exit state (matches legacy initial values)
    FLAGS(FLAG_BRIDGE_CONDITION) = ROOM_BRIDGE_MID
    FLAGS(FLAG_DRAWBRIDGE_STATE) = EXIT_FATAL
    FLAGS(FLAG_WATER_EXIT_LOCATION) = 0
    FLAGS(FLAG_GATE_DESTINATION) = 0
    FLAGS(FLAG_TELEPORT_DESTINATION) = 0
    FLAGS(FLAG_SECRET_EXIT_LOCATION) = 0

    FLAGS(FLAG_HUT_VISITED) = 0
    FLAGS(FLAG_HOSTILE_CREATURE_INDEX) = 0
    FLAGS(FLAG_CANDLE_LIT) = 1
    FLAGS(FLAG_SWORD_SWING_COUNT) = 0
    FLAGS(FLAG_SCORE) = 0

    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

READ_INPUT_AND_PARSE_SUB:
    input INPUT_COMMAND$
    if INPUT_COMMAND$ = "" then
        goto READ_INPUT_AND_PARSE_SUB
    end if

    INPUT_COMMAND$ = " " + INPUT_COMMAND$ + " "
    TURN_COUNTER = TURN_COUNTER + 1

    gosub NORMALIZE_INPUT_SUB

    FLAGS(FLAG_SPECIAL_WORD) = SPECIAL_NONE
    FLAGS(FLAG_CURRENT_VERB) = VERB_NONE
    FLAGS(FLAG_CURRENT_DIR) = 255
    FLAGS(FLAG_CURRENT_OBJECT) = 0
    FLAGS(FLAG_VERB_PATTERN_INDEX) = 0

    rem Special tokens
    if INSTR(INPUT_COMMAND$, " look ") > 0 then FLAGS(FLAG_SPECIAL_WORD) = SPECIAL_LOOK
    if INSTR(INPUT_COMMAND$, " list ") > 0 then FLAGS(FLAG_SPECIAL_WORD) = SPECIAL_LIST
    if INSTR(INPUT_COMMAND$, " quit ") > 0 then FLAGS(FLAG_SPECIAL_WORD) = SPECIAL_QUIT
    if INSTR(INPUT_COMMAND$, " galar ") > 0 then FLAGS(FLAG_SPECIAL_WORD) = SPECIAL_GALAR
    if INSTR(INPUT_COMMAND$, " ape ") > 0 then FLAGS(FLAG_SPECIAL_WORD) = SPECIAL_APE

    rem Direct verb tokens (preferred when present)
    if INSTR(INPUT_COMMAND$, " get ") > 0 then FLAGS(FLAG_CURRENT_VERB) = VERB_GET
    if INSTR(INPUT_COMMAND$, " drop ") > 0 then FLAGS(FLAG_CURRENT_VERB) = VERB_DROP
    if INSTR(INPUT_COMMAND$, " use ") > 0 then FLAGS(FLAG_CURRENT_VERB) = VERB_USE

    rem Direction parsing (first match wins)
    for DIRECTION_INDEX = 0 to 3
        if INSTR(INPUT_COMMAND$, @DIR_WORD_INDEX(DIRECTION_INDEX+1)) > 0 then
            FLAGS(FLAG_CURRENT_DIR) = DIRECTION_INDEX
            EXIT for
        end if
    next DIRECTION_INDEX

    rem Verb patterns: normalize a few to verbs, keep legacy index for the rest
    for VERB_PATTERN_INDEX = 1 to 16
        if INSTR(INPUT_COMMAND$, @VERB_PATTERN(VERB_PATTERN_INDEX)) > 0 then
            FLAGS(FLAG_VERB_PATTERN_INDEX) = VERB_PATTERN_INDEX
            if FLAGS(FLAG_CURRENT_VERB) = VERB_NONE then
                select case VERB_PATTERN_INDEX
                    case 1
                        FLAGS(FLAG_CURRENT_VERB) = VERB_GET
                    case 2
                        FLAGS(FLAG_CURRENT_VERB) = VERB_DROP
                    case 3,4
                        FLAGS(FLAG_CURRENT_VERB) = VERB_USE
                end select
            end if
            EXIT for
        end if
    next VERB_PATTERN_INDEX

    rem Object noun parsing (7..24)
    for LOOP_INDEX = 7 to 24
        OBJECT_NOUN$ = @OBJECT_NAME_NOUN(LOOP_INDEX)
        if INSTR(INPUT_COMMAND$, OBJECT_NOUN$) > 0 then
            FLAGS(FLAG_CURRENT_OBJECT) = LOOP_INDEX
            EXIT for
        end if
    next LOOP_INDEX

    return

UPDATE_HOSTILE_SUB:
    FLAGS(FLAG_HOSTILE_CREATURE_INDEX) = 0
    for I=1 to 6
        if ENTITY_LOCATION(I) = PLAYER_LOCATION then
            FLAGS(FLAG_HOSTILE_CREATURE_INDEX) = I
            return
        end if
    next I
    return

ACT_NOOP_SUB: return
ACT_FORCE_REDESCRIBE_SUB:
    rem No-op: main loop always runs PHASE_DESCRIBE after command
    return

ACT_PRINT_EH_SUB:
    print "eh?"
    return

ACT_PRINT_WHERE_I_CANT_SEE_IT_SUB:
    print "Where? I can't see it."
    return

ACT_PRINT_TOO_DANGEROUS_SUB:
    print "It's too dangerous!!!"
    return

ACT_PRINT_IT_WONT_OPEN_SUB:
    print "It won't open!"
    return

ACT_PRINT_NOTHING_TO_KILL_SUB:
    print "But there's nothing to kill..."
    return

ACT_PRINT_PATTERN_RESPONSE_SUB:
    select case FLAGS(FLAG_VERB_PATTERN_INDEX)
        case 5,6
            print "Nothing happens!"
        case 7 to 12
            print "Please tell me how."
        case else
            print "I can't!"
    end select
    return

ACT_PRINT_INVENTORY_SUB:
    print "You are carrying ";
    CARRIED_COUNT = 0
    for LOOP_INDEX = 7 to 24
        if ENTITY_LOCATION(LOOP_INDEX) = ENT_LOC_CARRIED then
            CARRIED_COUNT = CARRIED_COUNT + 1
        end if
    next LOOP_INDEX
    if CARRIED_COUNT = 0 then
        print "nothing."
        return
    end if
    print
    for LOOP_INDEX = 7 to 24
        if ENTITY_LOCATION(LOOP_INDEX) = ENT_LOC_CARRIED then
            CURRENT_OBJECT_INDEX = LOOP_INDEX
            gosub PRINT_OBJECT_DESCRIPTION_SUB
        end if
    next LOOP_INDEX
    return

ACT_QUIT_AND_SCORE_SUB:
    SCORE = 0
    for LOOP_INDEX = 7 to 17
        if ENTITY_LOCATION(LOOP_INDEX) = ENT_LOC_CARRIED then
            SCORE = SCORE + LOOP_INDEX - 6
        end if
        if ENTITY_LOCATION(LOOP_INDEX) = 1 then
            SCORE = SCORE + (LOOP_INDEX - 6) * 2
        end if
    next LOOP_INDEX
    FLAGS(FLAG_SCORE) = SCORE
    print
    print "You have a score of"; SCORE; " out of a possible 126 points in"; TURN_COUNTER; " moves."
    gosub PRINT_RANKING_SUB
    print "Another adventure? ";
    PLAYER_ALIVE = 0
    return

ACT_TELEPORT_TO_CAVE_ENTRY_SUB:
    print "Suddenly a magic wind carried you to another place..."
    PLAYER_LOCATION = ROOM_CAVE_ENTRY
    FLAGS(FLAG_PLAYER_MOVED) = 1
    return

ACT_OPEN_CRYPT_SECRET_EXIT_AND_PATCH_SUB:
    print "Hey! the eastern wall of the crypt slid open..."
    FLAGS(FLAG_SECRET_EXIT_LOCATION) = ROOM_TINY_CELL
    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

ACT_TRY_GET_CURRENT_OBJECT_SUB:
    OBJ = FLAGS(FLAG_CURRENT_OBJECT)
    CARRIED_COUNT = 0
    for LOOP_INDEX = 7 to 24
        if ENTITY_LOCATION(LOOP_INDEX) = ENT_LOC_CARRIED then
            CARRIED_COUNT = CARRIED_COUNT + 1
        end if
    next LOOP_INDEX
    if CARRIED_COUNT > 10 then
        print "You are carrying too many objects."
        return
    end if
    ENTITY_LOCATION(OBJ) = ENT_LOC_CARRIED
    return

ACT_DROP_CURRENT_OBJECT_SUB:
    OBJ = FLAGS(FLAG_CURRENT_OBJECT)
    ENTITY_LOCATION(OBJ) = PLAYER_LOCATION
    return

ACT_USE_KEY_FOREST_SUB:
    print "You opened the door."
    ENTITY_LOCATION(OBJ_KEY) = PLAYER_LOCATION
    PLAYER_LOCATION = ROOM_DARK_ROOM
    FLAGS(FLAG_PLAYER_MOVED) = 1
    return

ACT_USE_KEY_TEMPLE_SUB:
    print "You opened the door."
    ENTITY_LOCATION(OBJ_KEY) = PLAYER_LOCATION
    PLAYER_LOCATION = ROOM_CRYPT
    FLAGS(FLAG_PLAYER_MOVED) = 1
    return

ACT_USE_ROPE_SUB:
    print "You descend the rope, but it drops 10 feet short of the floor. You jump the rest of the way."
    ENTITY_LOCATION(OBJ_ROPE) = PLAYER_LOCATION
    PLAYER_LOCATION = ROOM_TEMPLE
    FLAGS(FLAG_PLAYER_MOVED) = 1
    return

ACT_USE_BOMB_SUB:
    if ENTITY_LOCATION(OBJ_BOMB) <> ENT_LOC_CARRIED and ENTITY_LOCATION(OBJ_BOMB) <> PLAYER_LOCATION then
        print "That won't burn, Dummy...In fact, the candle went out."
        FLAGS(FLAG_CANDLE_LIT) = 0
        return
    end if
    if FLAGS(FLAG_CANDLE_LIT) <> 1 then
        print "But the candle is out, stupid!!"
        return
    end if
    print "The fuse burnt away and....BOOM!!....the explosion blew you out of the way (Lucky!)"
    if PLAYER_LOCATION > ROOM_DARK_ROOM then
        PLAYER_LOCATION = PLAYER_LOCATION - 1
        if PLAYER_LOCATION = ROOM_OAK_DOOR then
            FLAGS(FLAG_TELEPORT_DESTINATION) = ROOM_TREASURE_ROOM
            gosub ACT_PATCH_DYNAMIC_EXITS_SUB
        end if
    end if
    ENTITY_LOCATION(OBJ_BOMB) = ENT_LOC_REMOVED
    FLAGS(FLAG_PLAYER_MOVED) = 1
    return

ACT_SWORD_COMBAT_SUB:
    HOSTILE = FLAGS(FLAG_HOSTILE_CREATURE_INDEX)
    if HOSTILE = 0 then
        print "But there's nothing to kill..."
        return
    end if

    FLAGS(FLAG_SWORD_SWING_COUNT) = FLAGS(FLAG_SWORD_SWING_COUNT) + 1

    if RND * 7 + 15 <= FLAGS(FLAG_SWORD_SWING_COUNT) then
        print "You swing with your sword but miss and the creature smashes your skull."
        PLAYER_ALIVE = 0
        return
    end if

    if RND < .38 then
        goto SWORD_KILLS_TARGET_DD
    end if

    if HOSTILE = ENT_BAT then
        gosub ACT_BAT_CARRY_SUB
        return
    end if

    RANDOM_FIGHT_MESSAGE = INT(RND * 4)
    select case RANDOM_FIGHT_MESSAGE
        case 0
            print "You attack but the creature moves aside."
        case 1
            print "The creature deflects your blow."
        case 2
            print "The foe is stunned but quickly regains his balance."
        case 3
            print "You missed and he deals a blow to your head."
    end select
    return

SWORD_KILLS_TARGET_DD:
    print "The sword strikes home and your foe dies..."

    rem NOTE: the legacy sets OBJECT_LOCATION(CURRENT_OBJECT_INDEX) = -1 here, but that
    rem variable was overloaded across loops and isn't meaningful in this action.
    rem The data-driven action only updates the hostile creature and prints text.

    rem Creature removal logic (legacy uses 0 or "+10" for troll/bat)
    if HOSTILE = ENT_TROLL or HOSTILE = ENT_BAT then
        ENTITY_LOCATION(HOSTILE) = ENTITY_LOCATION(HOSTILE) + 10
    else
        ENTITY_LOCATION(HOSTILE) = ENT_LOC_REMOVED
        if HOSTILE = ENT_WIZARD then
            print "Hey! Your sword has just crumbled into dust!!"
            ENTITY_LOCATION(OBJ_SWORD) = ROOM_TEMPLE
        end if
    end if

    if HOSTILE <> ENT_DRAGON then
        print "Suddenly a black cloud descends and the corpse vaporizes into nothing."
    end if

    FLAGS(FLAG_HOSTILE_CREATURE_INDEX) = 0
    return

ACT_RESOLVE_MOVEMENT_SUB:
    DIR = FLAGS(FLAG_CURRENT_DIR)
    rem Suggested fix: only randomize dir under bomb condition (preserve typed dir otherwise)
    if ENTITY_LOCATION(OBJ_BOMB) <> ENT_LOC_CARRIED and ENTITY_LOCATION(OBJ_BOMB) <> PLAYER_LOCATION and ENTITY_LOCATION(OBJ_BOMB) <> ENT_LOC_REMOVED then
        DIR = INT(RND * 4)
    end if

    TARGET = MOVEMENT_TABLE(PLAYER_LOCATION, DIR)
    if TARGET = EXIT_NONE then
        print "You can't go that way"
        return
    end if
    if TARGET = EXIT_FATAL then
        print "You stumble and fall into the chasm and smash yourself to a pulp on the rocks below."
        PLAYER_ALIVE = 0
        return
    end if
    if TARGET > 0 then
        PLAYER_LOCATION = TARGET
        FLAGS(FLAG_PLAYER_MOVED) = 1
    end if
    return

ACT_SET_BRIDGE_FATAL_AND_PATCH_SUB:
    if FLAGS(FLAG_BRIDGE_CONDITION) <> EXIT_FATAL then
        FLAGS(FLAG_BRIDGE_CONDITION) = EXIT_FATAL
        gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    end if
    return

ACT_SET_HUT_VISITED_SUB:
    FLAGS(FLAG_HUT_VISITED) = 1
    return

ACT_ENABLE_WATER_EXIT_AND_PATCH_SUB:
    FLAGS(FLAG_WATER_EXIT_LOCATION) = ROOM_DRAIN_C
    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

ACT_DISABLE_WATER_EXIT_AND_PATCH_SUB:
    FLAGS(FLAG_WATER_EXIT_LOCATION) = 0
    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

ACT_SET_GATE_DEST_AND_PATCH_SUB:
    FLAGS(FLAG_GATE_DESTINATION) = ROOM_DARK_CAVERN_J
    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

ACT_CLEAR_GATE_DEST_AND_PATCH_SUB:
    FLAGS(FLAG_GATE_DESTINATION) = 0
    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

ACT_SET_DRAWBRIDGE_AND_PATCH_SUB:
    FLAGS(FLAG_DRAWBRIDGE_STATE) = ROOM_DRAWBRIDGE
    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

ACT_CLEAR_DRAWBRIDGE_AND_PATCH_SUB:
    FLAGS(FLAG_DRAWBRIDGE_STATE) = EXIT_FATAL
    gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    return

ACT_CLEAR_TELEPORT_DEST_AND_PATCH_SUB:
    if FLAGS(FLAG_TELEPORT_DESTINATION) <> 0 then
        FLAGS(FLAG_TELEPORT_DESTINATION) = 0
        gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    end if
    return

ACT_CLEAR_SECRET_EXIT_AND_PATCH_SUB:
    if FLAGS(FLAG_SECRET_EXIT_LOCATION) <> 0 then
        FLAGS(FLAG_SECRET_EXIT_LOCATION) = 0
        gosub ACT_PATCH_DYNAMIC_EXITS_SUB
    end if
    return

ACT_PATCH_DYNAMIC_EXITS_SUB:
    MOVEMENT_TABLE(ROOM_BRIDGE_NORTH_ANCHOR,DIR_SOUTH_STR) = FLAGS(FLAG_BRIDGE_CONDITION)
    MOVEMENT_TABLE(ROOM_BRIDGE_SOUTH_ANCHOR,DIR_NORTH_STR) = FLAGS(FLAG_BRIDGE_CONDITION)
    MOVEMENT_TABLE(ROOM_OAK_DOOR,DIR_EAST_STR) = FLAGS(FLAG_TELEPORT_DESTINATION)
    MOVEMENT_TABLE(ROOM_CRYPT,DIR_EAST_STR) = FLAGS(FLAG_SECRET_EXIT_LOCATION)
    MOVEMENT_TABLE(ROOM_TINY_CELL,DIR_NORTH_STR) = FLAGS(FLAG_WATER_EXIT_LOCATION)
    MOVEMENT_TABLE(ROOM_TINY_CELL,DIR_EAST_STR) = FLAGS(FLAG_GATE_DESTINATION)
    MOVEMENT_TABLE(ROOM_CASTLE_LEDGE,DIR_EAST_STR) = FLAGS(FLAG_DRAWBRIDGE_STATE)
    return

ACT_BAT_CARRY_SUB:
    print "The giant bat picked you up and carried you to another place."
    OLDROOM = ENTITY_LOCATION(ENT_BAT)
    ENTITY_LOCATION(ENT_BAT) = OLDROOM + 7
    if ENTITY_LOCATION(ENT_BAT) > ROOM_MAX then
        ENTITY_LOCATION(ENT_BAT) = ROOM_BAT_CAVE
    end if
    PLAYER_LOCATION = ROOM_BAT_CAVE
    FLAGS(FLAG_PLAYER_MOVED) = 1
    return

ACT_MONSTER_ATTACK_AND_KILL_SUB:
    MONSTER_ADJECTIVE$ = @MONSTER_ADJ(FLAGS(FLAG_HOSTILE_CREATURE_INDEX))
    MONSTER_NOUN$ = @MONSTER_NOUN(FLAGS(FLAG_HOSTILE_CREATURE_INDEX))
    print "AUUUUUGH...you've just been killed by a"; MONSTER_ADJECTIVE$; MONSTER_NOUN$; "!!"
    PLAYER_ALIVE = 0
    return

ACT_DESCRIBE_LIT_SUB:
    if ROOM_DESC1_PTR(PLAYER_LOCATION) <> NULL then
        print @ROOM_DESC1_PTR(PLAYER_LOCATION)
    end if
    if ROOM_DESC2_PTR(PLAYER_LOCATION) <> NULL then
        print @ROOM_DESC2_PTR(PLAYER_LOCATION)
    end if

    gosub PRINT_ROOM_EXTRAS_SUB
    gosub LIST_VISIBLE_ENTITIES_SUB
    print
    print ">";
    return

ACT_DESCRIBE_DARK_SUB:
    print "It's very dark, too dark to see anything...I'm scared!"
    gosub LIST_VISIBLE_ENTITIES_SUB
    print
    print ">";
    return

PRINT_ROOM_EXTRAS_SUB:
    if PLAYER_LOCATION > ROOM_LEDGE_WATERFALL_IN and PLAYER_LOCATION < ROOM_WATERFALL_BASE then
        print "Somehow you have gotten into the complex drainage system of this entire cavern network!!"
    end if

    if PLAYER_LOCATION = ROOM_DARK_CAVERN_A or PLAYER_LOCATION = ROOM_DARK_CAVERN_B or PLAYER_LOCATION = ROOM_DARK_CAVERN_C or PLAYER_LOCATION > ROOM_TEMPLE_BALCONY and PLAYER_LOCATION < ROOM_DARK_CAVERN_G or PLAYER_LOCATION = ROOM_DARK_CAVERN_H or PLAYER_LOCATION = ROOM_DARK_CAVERN_I or PLAYER_LOCATION = ROOM_DARK_CAVERN_J or PLAYER_LOCATION = ROOM_DARK_CAVERN_K or PLAYER_LOCATION = ROOM_WOODEN_BRIDGE then
        print "You are deep in a dark cavern."
    end if

    if (PLAYER_LOCATION = ROOM_BRIDGE_NORTH_ANCHOR or PLAYER_LOCATION = ROOM_BRIDGE_SOUTH_ANCHOR) and FLAGS(FLAG_BRIDGE_CONDITION) = EXIT_FATAL then
        print "Two of the ropes have snapped under your weight. It's totally unfit to cross again."
    end if

    if PLAYER_LOCATION = ROOM_CAVE_ENTRANCE_CLEARING and ENTITY_LOCATION(ENT_DRAGON) = ENT_LOC_REMOVED then
        print "You can also see the bloody corpse of an enormous dragon."
    end if

    if PLAYER_LOCATION = ROOM_CASTLE_LEDGE and FLAGS(FLAG_DRAWBRIDGE_STATE) = ROOM_DRAWBRIDGE then
        print " A mighty golden drawbridge spans the waters."
    end if

    if TURN_COUNTER > 200 then
        print "Your candle is growing dim."
    end if
    if TURN_COUNTER >= 230 then
        FLAGS(FLAG_CANDLE_LIT) = 0
        print "In fact...it went out!"
    end if
    return

LIST_VISIBLE_ENTITIES_SUB:
    VISIBLE_OBJECT_COUNT = 0
    for LOOP_INDEX = 7 to 24
        if ENTITY_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
            VISIBLE_OBJECT_COUNT = VISIBLE_OBJECT_COUNT + 1
        end if
    next LOOP_INDEX

    if VISIBLE_OBJECT_COUNT > 0 then
        print "You can also see..."
        for LOOP_INDEX = 7 to 24
            if ENTITY_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
                CURRENT_OBJECT_INDEX = LOOP_INDEX
                gosub PRINT_OBJECT_DESCRIPTION_SUB
            end if
        next LOOP_INDEX
    end if

    VISIBLE_CREATURE_COUNT = 0
    for LOOP_INDEX = 1 to 6
        if ENTITY_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
            VISIBLE_CREATURE_COUNT = VISIBLE_CREATURE_COUNT + 1
            CURRENT_OBJECT_INDEX = LOOP_INDEX
            gosub TRIGGER_CREATURE_INTRO_SUB
        end if
    next LOOP_INDEX

    if VISIBLE_CREATURE_COUNT > 0 then
        print "Nearby there lurks..."
        for LOOP_INDEX = 1 to 6
            if ENTITY_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
                CURRENT_OBJECT_INDEX = LOOP_INDEX
                gosub PRINT_OBJECT_DESCRIPTION_SUB
            end if
        next LOOP_INDEX
    end if
    return

rem ---------------------------------------------------------
rem  Step 1: Conversion Ledger (what must become rules/actions)
rem ---------------------------------------------------------
rem  This is the authoritative inventory of pseudo3 decision points and side effects.
rem  Each item below must map to either:
rem    - a rule (guards + action), or
rem    - a pure action routine (imperative implementation detail).
rem
rem  Describe / visibility / UI
rem   L1  DESCRIBE_CURRENT_LOCATION hostile gating:
rem         if hostile != 0 AND hostile != bat AND current object != sword -> MONSTER_ATTACK
rem         => PHASE_DESCRIBE rule + ACT_MONSTER_ATTACK_AND_KILL
rem   L2  Darkness selection:
rem         room < ROOM_DARK_CAVERN_A OR (candle lit AND candle visible) -> print room desc
rem         else -> print darkness msg
rem         => PHASE_DESCRIBE rules (see guard examples above)
rem   L3  Room extras after description:
rem         - drainage message (rooms 41..44)
rem         - "deep in dark cavern" message (many rooms)
rem         - snapped bridge ropes message (bridge anchors when BRIDGE_CONDITION = EXIT_FATAL)
rem         - dragon corpse message (at cave clearing when dragon removed)
rem         - drawbridge spans waters message (castle ledge when drawbridge state)
rem         - candle dim/out messages and turning candle off at turn thresholds
rem         => typically: ACT_PRINT_ROOM_EXTRAS (+ possibly PHASE_ON_ENTER for candle decay)
rem   L4  LIST_ROOM_OBJECTS_AND_CREATURES:
rem         - count objects present, print "You can also see..." and list them
rem         - creature intro side effects (wizard/dragon/dwarf specific text)
rem         - print "Nearby there lurks..." and list creatures
rem         => ACT_LIST_VISIBLE_ENTITIES (may call a small intro-table internally)
rem   L5  Prompt + reshow flag:
rem         RESHOW_FLAG = 1, print ">"
rem         => ACT_PROMPT (+ optional flag if still needed)
rem
rem  Input / parsing / turn tick
rem   L6  GET_PLAYER_INPUT:
rem         - reject empty input
rem         - surround with spaces
rem         - TURN_COUNTER++
rem         - NORMALIZE_INPUT_SUB (lowercase)
rem         - cls
rem         => ACT_READ_INPUT_AND_NORMALIZE
rem   L7  PARSE_COMMAND_ENTRY (object noun detection):
rem         - scan objects 7..24 nouns, set CURRENT_OBJECT_INDEX or 0
rem         => ACT_PARSE_INPUT sets FLAG_CURRENT_OBJECT
rem   L8  ROUTE_BY_VERB_PATTERN + DIR_WORD parsing:
rem         - pattern scan 1..16 => route get/drop/use/print canned responses
rem         - direction word scan 0..3 => movement
rem         => ACT_PARSE_INPUT sets FLAG_CURRENT_VERB / FLAG_CURRENT_DIR / FLAG_SPECIAL_WORD
rem
rem  Dynamic exits (currently updated during parsing; should become PHASE_ON_ENTER)
rem   L9  Bridge midpoint:
rem         if at ROOM_BRIDGE_MID: BRIDGE_CONDITION = EXIT_FATAL; patch exits
rem         => PHASE_ON_ENTER rule + ACT_PATCH_DYNAMIC_EXITS
rem   L10 Hut visited flag:
rem         if at ROOM_FOREST_CLEARING: GENERAL_FLAG_J = 1
rem         => PHASE_ON_ENTER rule + ACT_SET_FLAG
rem   L11 Water exit:
rem         at ROOM_WATERFALL_BASE: WATER_EXIT_LOCATION=43; patch
rem         at ROOM_TEMPLE: WATER_EXIT_LOCATION=0; patch
rem         => PHASE_ON_ENTER rules + ACT_PATCH_DYNAMIC_EXITS
rem   L12 Gate destination:
rem         if grill not in tiny cell: GATE_DESTINATION=39; patch
rem         => PHASE_ON_ENTER rule + ACT_PATCH_DYNAMIC_EXITS
rem   L13 Drawbridge state:
rem         if at ROOM_DRAWBRIDGE: DRAWBRIDGE_STATE=49; patch
rem         => PHASE_ON_ENTER rule + ACT_PATCH_DYNAMIC_EXITS
rem   L14 UPDATE_DYNAMIC_EXITS_SUB patch slots:
rem         7 fixed MOVEMENT_TABLE writes (listed above in overlay)
rem         => single action ACT_PATCH_DYNAMIC_EXITS
rem
rem  Special commands
rem   L15 LOOK:
rem         RESHOW_FLAG=0; redraw description
rem         => PHASE_ON_COMMAND rule + action to re-run PHASE_DESCRIBE
rem   L16 LIST:
rem         print inventory listing (objects carried)
rem         => PHASE_ON_COMMAND rule + ACT_PRINT_INVENTORY
rem   L17 QUIT:
rem         compute score, print score + ranking, prompt restart
rem         => PHASE_ON_COMMAND rule + ACT_QUIT_AND_SCORE
rem   L18 Magic word GALAR:
rem         teleport to cave entry
rem         => PHASE_ON_COMMAND rule + ACT_TELEPORT_TO(room)
rem   L19 Crypt wall APE:
rem         set secret exit; patch exits; redraw
rem         => PHASE_ON_COMMAND rule + ACT_OPEN_CRYPT_SECRET_EXIT (+ patch)
rem
rem  Hostile detection + special bat behaviour
rem   L20 CHECK_CREATURE_AT_LOCATION:
rem         scan 1..6 for creature at player -> HOSTILE_CREATURE_INDEX, else 0
rem         => ACT_UPDATE_HOSTILE_CREATURE_INDEX (run before phases)
rem   L21 Bat special:
rem         if hostile == bat:
rem           print carry message
rem           PLAYER_LOCATION = ROOM_BAT_CAVE
rem           mutate bat location (OBJECT_LOCATION(5) += 7)
rem           redraw
rem         => PHASE_ON_ENTER or PHASE_DESCRIBE rule + ACT_BAT_CARRY (game-specific)
rem
rem  Movement
rem   L22 Random-direction quirk:
rem         if bomb exists and not carried and not at player:
rem           RANDOM_DIRECTION_INDEX = random(0..3)
rem         else RANDOM_DIRECTION_INDEX=0
rem         => part of ACT_RESOLVE_MOVEMENT (game-specific)
rem   L23 Exit resolution:
rem         TARGET = MOVEMENT_TABLE(player, dir)
rem         0 -> "can't go that way"
rem         EXIT_FATAL -> death text + quit
rem         >0 -> move player
rem         => PHASE_ON_COMMAND movement rules + ACT_RESOLVE_MOVEMENT
rem
rem  Object interaction gate
rem   L24 If no object parsed:
rem         print "eh?"
rem         => PHASE_ON_COMMAND fallback rule
rem   L25 Must be carried or at player location:
rem         else "Where? I can't see it."
rem         => PHASE_ON_COMMAND rule (NOT G_ENT_VISIBLE)
rem
rem  Inventory verbs
rem   L26 GET:
rem         count carried >10 -> "too many objects"
rem         else set carried
rem         => ACT_TRY_GET_CURRENT_OBJECT
rem   L27 DROP:
rem         set object location to player
rem         => ACT_DROP_CURRENT_OBJECT
rem
rem  USE routing and behaviors
rem   L28 USE unknown:
rem         "How am I supposed to use it?"
rem         => PHASE_ON_COMMAND fallback in USE group
rem   L29 USE KEY:
rem         only in forest clearing or temple; prints; drops key; moves player to dark room or crypt
rem         => ACT_USE_KEY (may be multiple rules by location)
rem   L30 USE SWORD:
rem         if no hostile -> "nothing to kill"
rem         else RNG combat:
rem           - swing count increments
rem           - chance player death
rem           - chance target death
rem           - special cases (wizard sword crumble; bat redirect)
rem           - corpse vaporize message (unless dragon)
rem         => ACT_SWORD_COMBAT (single action invoked by rules)
rem   L31 USE BOMB (pseudo3 routes candle -> bomb):
rem         - if bomb not present: candle goes out message and clear candle lit
rem         - if candle out: insult message
rem         - explosion: move player back a room; set teleport destination if at oak door; remove bomb
rem         => ACT_USE_BOMB (game-specific)
rem   L32 USE ROPE:
rem         only at temple balcony; drops rope; moves to temple
rem         => ACT_USE_ROPE (guard by location)
rem
rem  Pure data/utility routines (stay imperative)
rem   L33 NORMALIZE_INPUT_SUB (lowercasing)
rem   L34 PRINT_OBJECT_DESCRIPTION_SUB (OBJDESC1/OBJDESC2 formatting)
rem   L35 TRIGGER_CREATURE_INTRO_SUB (wizard/dragon/dwarf intro)
rem   L36 PRINT_RANKING_SUB (ranking text)
rem
rem =========================================================

rem =========================================================
rem  Appendix: Legacy Imperative Listing (reference only)
rem =========================================================
rem The section below is the older label/goto pseudo-BASIC representation.
rem It is retained to validate the conversion ledger, but it is NOT the target
rem execution model anymore. The intended model is the data-driven overlay above.
rem
rem When converting to assembler tables + interpreter, translate this appendix using:
rem   - Step 1 conversion ledger
rem   - RULE_TABLE skeleton
rem   - guard lists + action specs
rem
rem ---------------------------------------------------------
rem  CAVERNS – Fictional BASIC Dialect Version
rem  Based on MicroWorld BASIC game by John Hardy (c) 1983
rem  No line numbers, label-based control flow, long variable names
rem ---------------------------------------------------------
rem  INDEX MAP (for future assembly translation)
rem  CREATURES: 1 wizard, 2 demon, 3 troll, 4 dragon, 5 bat, 6 dwarf
rem  OBJECTS 7-24: coin, compass, bomb, ruby, diamond, pearl, stone,
rem                ring, pendant, grail, shield, box, key, sword,
rem                candle, rope, brick, grill
rem  ROOM FLAGS: BRIDGE_CONDITION/H, DRAWBRIDGE_STATE/D,
rem              WATER_EXIT_LOCATION/W, GATE_DESTINATION/G,
rem              TELEPORT_DESTINATION/T, SECRET_EXIT_LOCATION/E
rem  DIRECTION INDEX: DIR_NORTH_STR=0, DIR_SOUTH_STR=1, DIR_WEST_STR=2, DIR_EAST_STR=3


GAME_START:

    cls

    BRIDGE_CONDITION = 11
    DRAWBRIDGE_STATE = 128
    WATER_EXIT_LOCATION = 0
    GATE_DESTINATION = 0
    TELEPORT_DESTINATION = 0
    SECRET_EXIT_LOCATION = 0

    ROOM_MAX = 54
    DIR_NORTH = 0: DIR_SOUTH = 1: DIR_WEST = 2: DIR_EAST = 3

    rem Room ID constants (1..54)
    ROOM_DARK_ROOM = 1
    ROOM_FOREST_CLEARING = 2
    ROOM_DARK_FOREST = 3
    ROOM_CLOVER_FIELD = 4
    ROOM_RIVER_CLIFF = 5
    ROOM_RIVER_BANK = 6
    ROOM_CRATER_EDGE = 7
    ROOM_RIVER_OUTCROP = 8
    ROOM_MT_YMIR_SLOPE = 9
    ROOM_BRIDGE_NORTH_ANCHOR = 10
    ROOM_BRIDGE_MID = 11
    ROOM_BRIDGE_SOUTH_ANCHOR = 12
    ROOM_MUSHROOM_ROCK = 13
    ROOM_CAVE_ENTRANCE_CLEARING = 14
    ROOM_CLIFF_FACE = 15
    ROOM_CAVE_ENTRY = 16
    ROOM_DEAD_END_INSCRIPTION = 17
    ROOM_DARK_CAVERN_A = 18
    ROOM_TREASURE_ROOM = 19
    ROOM_OAK_DOOR = 20
    ROOM_DARK_CAVERN_B = 21
    ROOM_WIND_CORRIDOR = 22
    ROOM_TORTURE_CHAMBER = 23
    ROOM_NORTH_SOUTH_TUNNEL = 24
    ROOM_DARK_CAVERN_C = 25
    ROOM_ROUND_ROOM = 26
    ROOM_LEDGE_OVER_RIVER = 27
    ROOM_TEMPLE_BALCONY = 28
    ROOM_DARK_CAVERN_D = 29
    ROOM_DARK_CAVERN_E = 30
    ROOM_DARK_CAVERN_F = 31
    ROOM_DARK_CAVERN_G = 32
    ROOM_BAT_CAVE = 33
    ROOM_DARK_CAVERN_H = 34
    ROOM_TEMPLE = 35
    ROOM_DARK_CAVERN_I = 36
    ROOM_CRYPT = 37
    ROOM_TINY_CELL = 38
    ROOM_DARK_CAVERN_J = 39
    ROOM_LEDGE_WATERFALL_IN = 40
    ROOM_DRAIN_A = 41
    ROOM_DRAIN_B = 42
    ROOM_DRAIN_C = 43
    ROOM_DRAIN_D = 44
    ROOM_WATERFALL_BASE = 45
    ROOM_DARK_CAVERN_K = 46
    ROOM_STONE_STAIRCASE = 47
    ROOM_CASTLE_LEDGE = 48
    ROOM_DRAWBRIDGE = 49
    ROOM_CASTLE_COURTYARD = 50
    ROOM_POWDER_MAG = 51
    ROOM_EAST_RIVERBANK = 52
    ROOM_WOODEN_BRIDGE = 53
ROOM_RIVER_CONDUIT = 54

    rem Exit codes
    EXIT_NONE = 0
    EXIT_FATAL = 128

    rem Turn thresholds for candle
    CANDLE_DIM_TURN = 200
    CANDLE_OUT_TURN = 230

    rem Object indices (7..24)
    OBJ_DRAGON = 4
    OBJ_BOMB = 9
    OBJ_GRILL = 24
    OBJ_KEY = 19
    OBJ_SWORD = 20
    OBJ_CANDLE = 21
    OBJ_ROPE = 22
    NULL = 0

    dim MOVEMENT_TABLE(ROOM_MAX,3)  rem byte-sized entries: room exit destination
    dim OBJECT_LOCATION(24)
    dim ROOM_DESC1_PTR(ROOM_MAX), ROOM_DESC2_PTR(ROOM_MAX)  rem pointers to description strings
    dim OBJECT_NAME_ADJ(24), OBJECT_NAME_NOUN(24)  rem pointers to strings
    dim MONSTER_ADJ(6), MONSTER_NOUN(6)            rem pointers to strings
    dim VERB_PATTERN(16)                           rem pointers to strings
    dim DIR_WORD_INDEX(4)                          rem pointers to strings
    dim OBJDESC1(24), OBJDESC2(24)                 rem pointers to strings

    GENERAL_FLAG_J = 0
    HOSTILE_CREATURE_INDEX = 0
    RESHOW_FLAG = 0
    PLAYER_LOCATION = ROOM_DARK_ROOM
    CANDLE_IS_LIT_FLAG = 1

    FEAR_COUNTER = 0
    TURN_COUNTER = 0
    SWORD_SWING_COUNT = 0
    SCORE = 0

    rem Data tables are pre-initialized (assembly targets will map these to DB/DW); no RESTORE/READ needed
    OBJECT_LOCATION = OBJECT_LOCATION_DATA
    OBJECT_NAME_ADJ = OBJECT_NAME_ADJ_DATA
    OBJECT_NAME_NOUN = OBJECT_NAME_NOUN_DATA
    MONSTER_ADJ = MONSTER_ADJ_DATA
    MONSTER_NOUN = MONSTER_NOUN_DATA
    VERB_PATTERN = VERB_PATTERN_DATA
    DIR_WORD_INDEX = DIR_WORD_INDEX_DATA
    OBJDESC1 = OBJDESC1_DATA
    OBJDESC2 = OBJDESC2_DATA

    gosub UPDATE_DYNAMIC_EXITS_SUB

    goto DESCRIBE_CURRENT_LOCATION



DESCRIBE_CURRENT_LOCATION:

    rem If a hostile creature is active (except some special case),
    rem jump to monster-attack logic
    if HOSTILE_CREATURE_INDEX > 0 and HOSTILE_CREATURE_INDEX <> 5 and CURRENT_OBJECT_INDEX <> OBJ_SWORD then
        goto MONSTER_ATTACK
    end if

    rem Darkness logic
    if PLAYER_LOCATION < ROOM_DARK_CAVERN_A or CANDLE_IS_LIT_FLAG = 1 and (OBJECT_LOCATION(21) = PLAYER_LOCATION or OBJECT_LOCATION(21) = -1) then
        goto PRINT_ROOM_DESCRIPTION
    end if

    print "It's very dark, too dark to see anything...I'm scared!"
    goto LIST_ROOM_OBJECTS_AND_CREATURES



PRINT_ROOM_DESCRIPTION:

    rem Pointer-based room descriptions (for assembly translation, @PTR means dereference)
    if ROOM_DESC1_PTR(PLAYER_LOCATION) <> NULL then
        print @ROOM_DESC1_PTR(PLAYER_LOCATION)
    end if

    if ROOM_DESC2_PTR(PLAYER_LOCATION) <> NULL then
        print @ROOM_DESC2_PTR(PLAYER_LOCATION)
    end if

    rem Drainage system message (pseudo.txt prints this for rooms 41..44)
    if PLAYER_LOCATION > ROOM_LEDGE_WATERFALL_IN and PLAYER_LOCATION < ROOM_WATERFALL_BASE then
        print "Somehow you have gotten into the complex drainage system of this entire cavern network!!"
    end if

    if PLAYER_LOCATION = ROOM_DARK_CAVERN_A or PLAYER_LOCATION = ROOM_DARK_CAVERN_B or PLAYER_LOCATION = ROOM_DARK_CAVERN_C or PLAYER_LOCATION > ROOM_TEMPLE_BALCONY and PLAYER_LOCATION < ROOM_DARK_CAVERN_G or PLAYER_LOCATION = ROOM_DARK_CAVERN_H or PLAYER_LOCATION = ROOM_DARK_CAVERN_I or PLAYER_LOCATION = ROOM_DARK_CAVERN_J or PLAYER_LOCATION = ROOM_DARK_CAVERN_K or PLAYER_LOCATION = ROOM_WOODEN_BRIDGE then
        print "You are deep in a dark cavern."
    end if

    if (PLAYER_LOCATION = ROOM_BRIDGE_NORTH_ANCHOR or PLAYER_LOCATION = ROOM_BRIDGE_SOUTH_ANCHOR) and BRIDGE_CONDITION = EXIT_FATAL then
        print "Two of the ropes have snapped under your weight. It's totally unfit to cross again."
    end if

    if PLAYER_LOCATION = ROOM_CAVE_ENTRANCE_CLEARING and OBJECT_LOCATION(OBJ_DRAGON) = 0 then
        print "You can also see the bloody corpse of an enormous dragon."
    end if

    if PLAYER_LOCATION = ROOM_CASTLE_LEDGE and DRAWBRIDGE_STATE = ROOM_DRAWBRIDGE then
        print " A mighty golden drawbridge spans the waters."
    end if

    if TURN_COUNTER > CANDLE_DIM_TURN then
        print "Your candle is growing dim."
    end if

    if TURN_COUNTER >= CANDLE_OUT_TURN then
        CANDLE_IS_LIT_FLAG = 0
        print "In fact...it went out!"
    end if

    goto LIST_ROOM_OBJECTS_AND_CREATURES



LIST_ROOM_OBJECTS_AND_CREATURES:

    VISIBLE_OBJECT_COUNT = 0

    for LOOP_INDEX = 7 to 24
        if OBJECT_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
            VISIBLE_OBJECT_COUNT = VISIBLE_OBJECT_COUNT + 1
        end if
    next LOOP_INDEX

    if VISIBLE_OBJECT_COUNT > 0 then
        print "You can also see..."
        for LOOP_INDEX = 7 to 24
            if OBJECT_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
                CURRENT_OBJECT_INDEX = LOOP_INDEX
                gosub PRINT_OBJECT_DESCRIPTION_SUB
            end if
        next LOOP_INDEX
    end if

    VISIBLE_CREATURE_COUNT = 0

    for LOOP_INDEX = 1 to 6
        if OBJECT_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
            VISIBLE_CREATURE_COUNT = VISIBLE_CREATURE_COUNT + 1
            CURRENT_OBJECT_INDEX = LOOP_INDEX
            gosub TRIGGER_CREATURE_INTRO_SUB
        end if
    next LOOP_INDEX

    if VISIBLE_CREATURE_COUNT > 0 then
        print "Nearby there lurks..."
        for LOOP_INDEX = 1 to 6
            if OBJECT_LOCATION(LOOP_INDEX) = PLAYER_LOCATION then
                CURRENT_OBJECT_INDEX = LOOP_INDEX
                gosub PRINT_OBJECT_DESCRIPTION_SUB
            end if
        next LOOP_INDEX
    end if

    print
    RESHOW_FLAG = 1
    print ">";

    if HOSTILE_CREATURE_INDEX > 0 and HOSTILE_CREATURE_INDEX <> 5 and CURRENT_OBJECT_INDEX <> 20 then
        goto MONSTER_ATTACK
    end if

    goto GET_PLAYER_INPUT



GET_PLAYER_INPUT:

    input INPUT_COMMAND$

    if INPUT_COMMAND$ = "" then
        goto GET_PLAYER_INPUT
    end if

    INPUT_COMMAND$ = " " + INPUT_COMMAND$ + " "
    TURN_COUNTER = TURN_COUNTER + 1

    gosub NORMALIZE_INPUT_SUB

    cls

    goto PARSE_COMMAND_ENTRY



PARSE_COMMAND_ENTRY:

    CURRENT_OBJECT_INDEX = 0
    OBJECT_ADJECTIVE$ = ""
    OBJECT_NOUN$ = ""

    for LOOP_INDEX = 7 to 24
        OBJECT_ADJECTIVE$ = @OBJECT_NAME_ADJ(LOOP_INDEX)
        OBJECT_NOUN$ = @OBJECT_NAME_NOUN(LOOP_INDEX)
        if INSTR(INPUT_COMMAND$, OBJECT_NOUN$) > 0 then
            CURRENT_OBJECT_INDEX = LOOP_INDEX
            EXIT for
        end if
    next LOOP_INDEX

    if CURRENT_OBJECT_INDEX = 0 then
        OBJECT_ADJECTIVE$ = ""
        OBJECT_NOUN$ = ""
    end if

    rem Bridge condition when halfway
    if PLAYER_LOCATION = ROOM_BRIDGE_MID then
        BRIDGE_CONDITION = 128
        gosub UPDATE_DYNAMIC_EXITS_SUB
    end if

    rem Hut flag
    if PLAYER_LOCATION = ROOM_FOREST_CLEARING then
        GENERAL_FLAG_J = 1
    end if

    if PLAYER_LOCATION = ROOM_WATERFALL_BASE then
        WATER_EXIT_LOCATION = 43
        gosub UPDATE_DYNAMIC_EXITS_SUB
    end if

    if PLAYER_LOCATION = ROOM_TEMPLE then
        WATER_EXIT_LOCATION = 0
        gosub UPDATE_DYNAMIC_EXITS_SUB
    end if

    if OBJECT_LOCATION(OBJ_GRILL) <> ROOM_TINY_CELL then
        GATE_DESTINATION = 39
        gosub UPDATE_DYNAMIC_EXITS_SUB
    end if

    if PLAYER_LOCATION = ROOM_DRAWBRIDGE then
        DRAWBRIDGE_STATE = 49
        gosub UPDATE_DYNAMIC_EXITS_SUB
    end if

    rem LOOK command
    if INSTR(INPUT_COMMAND$, " look ") > 0 then
        RESHOW_FLAG = 0
        goto DESCRIBE_CURRENT_LOCATION
    end if

    rem LIST inventory
    if INSTR(INPUT_COMMAND$, " list ") > 0 then
        goto SHOW_INVENTORY
    end if

    rem QUIT
    if INSTR(INPUT_COMMAND$, " quit ") > 0 then
        goto QUIT_GAME
    end if

    goto CHECK_CREATURE_AT_LOCATION



SHOW_INVENTORY:

    print "You are carrying ";
    VISIBLE_OBJECT_COUNT = 0

    for LOOP_INDEX = 7 to 24
        if OBJECT_LOCATION(LOOP_INDEX) = -1 then
            VISIBLE_OBJECT_COUNT = VISIBLE_OBJECT_COUNT + 1
        end if
    next LOOP_INDEX

    if VISIBLE_OBJECT_COUNT = 0 then
        print "nothing."
        goto DESCRIBE_CURRENT_LOCATION
    end if

    print
    for LOOP_INDEX = 7 to 24
        if OBJECT_LOCATION(LOOP_INDEX) = -1 then
            CURRENT_OBJECT_INDEX = LOOP_INDEX
            gosub PRINT_OBJECT_DESCRIPTION_SUB
        end if
    next LOOP_INDEX

    goto DESCRIBE_CURRENT_LOCATION



QUIT_GAME:

    SCORE = 0

    for LOOP_INDEX = 7 to 17
        if OBJECT_LOCATION(LOOP_INDEX) = -1 then
            SCORE = SCORE + LOOP_INDEX - 6
        end if
        if OBJECT_LOCATION(LOOP_INDEX) = 1 then
            SCORE = SCORE + (LOOP_INDEX - 6) * 2
        end if
    next LOOP_INDEX

    print
    print "You have a score of"; SCORE; " out of a possible 126 points in"; TURN_COUNTER; " moves."

    gosub PRINT_RANKING_SUB

    print "Another adventure? ";

WAIT_FOR_YES_NO:
    YESNO_KEY$ = INKEY$
    if YESNO_KEY$ = "" then
        goto WAIT_FOR_YES_NO
    end if

    if YESNO_KEY$ = "N" or YESNO_KEY$ = "n" then
        end
    end if

    if YESNO_KEY$ = "Y" or YESNO_KEY$ = "y" then
        goto GAME_START
    end if

    goto WAIT_FOR_YES_NO



CHECK_CREATURE_AT_LOCATION:

    for HOSTILE_CREATURE_INDEX = 1 to 6
        if OBJECT_LOCATION(HOSTILE_CREATURE_INDEX) = PLAYER_LOCATION then
            goto CHECK_CREATURE_BAT_SPECIAL
        end if
    next HOSTILE_CREATURE_INDEX

    HOSTILE_CREATURE_INDEX = 0
    goto HANDLE_VERB_OR_MOVEMENT



CHECK_CREATURE_BAT_SPECIAL:

    if HOSTILE_CREATURE_INDEX = 5 then
        print "The giant bat picked you up and carried you to another place."
        PLAYER_LOCATION = ROOM_BAT_CAVE
        RESHOW_FLAG = 0
        OBJECT_LOCATION(5) = OBJECT_LOCATION(5) + 7
        goto DESCRIBE_CURRENT_LOCATION
    end if

    goto HANDLE_VERB_OR_MOVEMENT



MONSTER_ATTACK:

    MONSTER_ADJECTIVE$ = @MONSTER_ADJ(HOSTILE_CREATURE_INDEX)
    MONSTER_NOUN$ = @MONSTER_NOUN(HOSTILE_CREATURE_INDEX)

    print "AUUUUUGH...you've just been killed by a"; MONSTER_ADJECTIVE$; MONSTER_NOUN$; "!!"

    goto QUIT_GAME



HANDLE_VERB_OR_MOVEMENT:

    rem First route generic verbs via the pattern table (take/put/unlock/jump/etc.)
    for VERB_PATTERN_INDEX = 1 to 16
        if INSTR(INPUT_COMMAND$, @VERB_PATTERN(VERB_PATTERN_INDEX)) > 0 then
            goto ROUTE_BY_VERB_PATTERN
        end if
    next VERB_PATTERN_INDEX

    rem Then check for movement (north/south/etc.)
    for DIRECTION_INDEX = 0 to 3
        if INSTR(INPUT_COMMAND$, @DIR_WORD_INDEX(DIRECTION_INDEX+1)) > 0 then
            goto HANDLE_MOVEMENT_COMMAND
        end if
    next DIRECTION_INDEX

    goto HANDLE_NON_MOVEMENT_COMMAND



HANDLE_MOVEMENT_COMMAND:

    rem Special check related to bomb or location
    if OBJECT_LOCATION(OBJ_BOMB) <> -1 and OBJECT_LOCATION(OBJ_BOMB) <> PLAYER_LOCATION then
        RANDOM_DIRECTION_INDEX = INT(RND * 4)
    else
        RANDOM_DIRECTION_INDEX = 0
    end if

    TARGET_LOCATION = MOVEMENT_TABLE(PLAYER_LOCATION, RANDOM_DIRECTION_INDEX)

    if TARGET_LOCATION = EXIT_NONE then
        print "You can't go that way"
    end if

    if TARGET_LOCATION = EXIT_FATAL then
        print "You stumble and fall into the chasm and smash yourself to a pulp on the rocks below."
        goto QUIT_GAME
    end if

    if TARGET_LOCATION > 0 then
        PLAYER_LOCATION = TARGET_LOCATION
    end if

    RESHOW_FLAG = 0
    goto DESCRIBE_CURRENT_LOCATION



HANDLE_NON_MOVEMENT_COMMAND:

    rem Magic word "galar"
    if INSTR(INPUT_COMMAND$, " galar ") > 0 then
        RESHOW_FLAG = 0
        print "Suddenly a magic wind carried you to another place..."
        PLAYER_LOCATION = ROOM_CAVE_ENTRY
        goto DESCRIBE_CURRENT_LOCATION
    end if

    rem Crypt wall "ape"
    if INSTR(INPUT_COMMAND$, " ape ") > 0 then
        print "Hey! the eastern wall of the crypt slid open..."
        SECRET_EXIT_LOCATION = 38
        gosub UPDATE_DYNAMIC_EXITS_SUB
        goto DESCRIBE_CURRENT_LOCATION
    end if

    if CURRENT_OBJECT_INDEX < 1 then
        print "eh?"
        goto DESCRIBE_CURRENT_LOCATION
    end if

    rem Object must be visible or carried
    if OBJECT_LOCATION(CURRENT_OBJECT_INDEX) = -1 or OBJECT_LOCATION(CURRENT_OBJECT_INDEX) = PLAYER_LOCATION then
        goto CHECK_GET_DROP_USE
    else
        print "Where? I can't see it."
        goto DESCRIBE_CURRENT_LOCATION
    end if



CHECK_GET_DROP_USE:

    rem GET command
    if INSTR(INPUT_COMMAND$, " get ") > 0 then
        goto HANDLE_GET_COMMAND
    end if

    rem DROP command
    if INSTR(INPUT_COMMAND$, " drop ") > 0 then
        goto HANDLE_DROP_COMMAND
    end if

    rem USE-type verbs routed by object index
    goto ROUTE_USE_BY_OBJECT



HANDLE_GET_COMMAND:

    CARRIED_COUNT = 0

    for LOOP_INDEX = 7 to 24
        if OBJECT_LOCATION(LOOP_INDEX) = -1 then
            CARRIED_COUNT = CARRIED_COUNT + 1
        end if
    next LOOP_INDEX

    if CARRIED_COUNT > 10 then
        print "You are carrying too many objects."
        goto DESCRIBE_CURRENT_LOCATION
    end if

    OBJECT_LOCATION(CURRENT_OBJECT_INDEX) = -1
    goto DESCRIBE_CURRENT_LOCATION



HANDLE_DROP_COMMAND:

    OBJECT_LOCATION(CURRENT_OBJECT_INDEX) = PLAYER_LOCATION
    goto DESCRIBE_CURRENT_LOCATION



ROUTE_USE_BY_OBJECT:

    select case CURRENT_OBJECT_INDEX
        case OBJ_KEY
            goto USE_KEY
        case OBJ_SWORD
            goto USE_SWORD
        case OBJ_CANDLE
            goto USE_BOMB
        case OBJ_ROPE
            goto USE_ROPE
        case else
            print "How am I supposed to use it?"
            goto DESCRIBE_CURRENT_LOCATION
    end select



USE_KEY:

    if PLAYER_LOCATION <> ROOM_FOREST_CLEARING and PLAYER_LOCATION <> ROOM_TEMPLE then
        print "It won't open!"
        goto DESCRIBE_CURRENT_LOCATION
    end if

    print "You opened the door."
    OBJECT_LOCATION(19) = PLAYER_LOCATION
    RESHOW_FLAG = 0

    if PLAYER_LOCATION = ROOM_FOREST_CLEARING then
        PLAYER_LOCATION = ROOM_DARK_ROOM
        goto DESCRIBE_CURRENT_LOCATION
    else
        PLAYER_LOCATION = ROOM_CRYPT
        goto DESCRIBE_CURRENT_LOCATION
    end if



USE_SWORD:

    if HOSTILE_CREATURE_INDEX = 0 then
        print "But there's nothing to kill..."
        goto DESCRIBE_CURRENT_LOCATION
    end if

    SWORD_SWING_COUNT = SWORD_SWING_COUNT + 1

    if RND * 7 + 15 > SWORD_SWING_COUNT then
        goto SWORD_FIGHT_CONTINUES
    end if

    print "You swing with your sword but miss and the creature smashes your skull."
    goto QUIT_GAME



SWORD_FIGHT_CONTINUES:

    if RND < .38 then
        goto SWORD_KILLS_TARGET
    end if

    RANDOM_FIGHT_MESSAGE = INT(RND * 4)

    if HOSTILE_CREATURE_INDEX = 5 then
        goto CHECK_CREATURE_BAT_SPECIAL
    end if

    select case RANDOM_FIGHT_MESSAGE
        case 0
            print "You attack but the creature moves aside."
        case 1
            print "The creature deflects your blow."
        case 2
            print "The foe is stunned but quickly regains his balance."
        case 3
            print "You missed and he deals a blow to your head."
    end select

    goto DESCRIBE_CURRENT_LOCATION



SWORD_KILLS_TARGET:

    print "The sword strikes home and your foe dies..."
    OBJECT_LOCATION(CURRENT_OBJECT_INDEX) = -1

    if HOSTILE_CREATURE_INDEX = 3 or HOSTILE_CREATURE_INDEX = 5 then
        OBJECT_LOCATION(HOSTILE_CREATURE_INDEX) = OBJECT_LOCATION(HOSTILE_CREATURE_INDEX) + 10
    else
        OBJECT_LOCATION(HOSTILE_CREATURE_INDEX) = 0
        if HOSTILE_CREATURE_INDEX = 1 then
            print "Hey! Your sword has just crumbled into dust!!"
            OBJECT_LOCATION(20) = 35
        end if
    end if

    if HOSTILE_CREATURE_INDEX <> 4 then
        print "Suddenly a black cloud descends and the corpse vaporizes into nothing."
    end if

    HOSTILE_CREATURE_INDEX = 0
    goto DESCRIBE_CURRENT_LOCATION



USE_BOMB:

    if OBJECT_LOCATION(9) <> -1 and OBJECT_LOCATION(9) <> PLAYER_LOCATION then
        print "That won't burn, Dummy...In fact, the candle went out."
        CANDLE_IS_LIT_FLAG = 0
        goto DESCRIBE_CURRENT_LOCATION
    end if

    if CANDLE_IS_LIT_FLAG <> 1 then
        print "But the candle is out, stupid!!"
        goto DESCRIBE_CURRENT_LOCATION
    end if

    print "The fuse burnt away and....BOOM!!....the explosion blew you out of the way (Lucky!)"
    RESHOW_FLAG = 0

    if PLAYER_LOCATION > ROOM_DARK_ROOM then
        PLAYER_LOCATION = PLAYER_LOCATION - 1
        if PLAYER_LOCATION = ROOM_OAK_DOOR then
            TELEPORT_DESTINATION = 19
            gosub UPDATE_DYNAMIC_EXITS_SUB
        end if
    end if

    OBJECT_LOCATION(9) = 0
    goto DESCRIBE_CURRENT_LOCATION



USE_ROPE:

    if PLAYER_LOCATION <> ROOM_TEMPLE_BALCONY then
        print "It's too dangerous!!!"
        goto DESCRIBE_CURRENT_LOCATION
    end if

    print "You descend the rope, but it drops 10 feet short of the floor. You jump the rest of the way."
    RESHOW_FLAG = 0
    OBJECT_LOCATION(CURRENT_OBJECT_INDEX) = PLAYER_LOCATION
    PLAYER_LOCATION = ROOM_TEMPLE
    goto DESCRIBE_CURRENT_LOCATION



PRINT_OBJECT_DESCRIPTION_SUB:

    print "a"; @OBJDESC1(CURRENT_OBJECT_INDEX); @OBJDESC2(CURRENT_OBJECT_INDEX); ", ";
    return



ROUTE_BY_VERB_PATTERN:

    select case VERB_PATTERN_INDEX
        case 1
            goto HANDLE_GET_COMMAND
        case 2
            goto HANDLE_DROP_COMMAND
        case 3,4
            goto ROUTE_USE_BY_OBJECT
        case 5,6
            print "Nothing happens!"
        case 7 to 12
            print "Please tell me how."
        case else
            print "I can't!"
    end select

    print
    goto GET_PLAYER_INPUT


NORMALIZE_INPUT_SUB:

    rem Convert uppercase to lowercase for parsing
    for LOOP_INDEX_X = 1 to LEN(INPUT_COMMAND$)
        CHARACTER_CODE = ASC(MID$(INPUT_COMMAND$, LOOP_INDEX_X, 1))
        if CHARACTER_CODE > 64 and CHARACTER_CODE < 91 then
            TEMP_COMMAND$ = LEFT$(INPUT_COMMAND$, LOOP_INDEX_X - 1) + CHR$(CHARACTER_CODE + 32) + MID$(INPUT_COMMAND$, LOOP_INDEX_X + 1)
            INPUT_COMMAND$ = TEMP_COMMAND$
        end if
    next LOOP_INDEX_X
    return


PRINT_RANKING_SUB:

    print "This gives you an adventurer's ranking of:"

    if SCORE < 20 then
        print "Hopeless beginner"
    elseif SCORE < 50 then
        print "Experienced loser"
    elseif SCORE < 100 then
        print "Average Viking"
    elseif SCORE < 126 then
        print "Excellent...but you've left something behind!"
    else
        print "Perfectionist and genius!!"
    end if

    return



READ_INPUT_THEN_CLEAR_SUB:

    input INPUT_COMMAND$
    cls
    return



ENCOUNTER_WIZARD_LABEL:

    print "There, before you in a swirling mist stands an evil wizard with his hand held outwards...`Thou shall not pass' he cries."
    goto LIST_ROOM_OBJECTS_AND_CREATURES



ENCOUNTER_DRAGON_LABEL:

    print "Before the entrance of the cave lies an enormous, green, sleeping dragon. Realizing your presence, its eyes flicker open"
    print "and it leaps up, breathing jets fire at you."
    goto LIST_ROOM_OBJECTS_AND_CREATURES



ENCOUNTER_DWARF_LABEL:

    print "From around the corner trots an old and gnarled drawf carrying a lantern. `My job is to protect these stone steps!' he says andlunges at you with his dagger."
    goto LIST_ROOM_OBJECTS_AND_CREATURES



TRIGGER_CREATURE_INTRO_SUB:

    select case CURRENT_OBJECT_INDEX
        case 1
            goto ENCOUNTER_WIZARD_LABEL
        case 4
            goto ENCOUNTER_DRAGON_LABEL
        case 6
            goto ENCOUNTER_DWARF_LABEL
    end select
    return



rem ---------------------------------------------------------
rem  DATA TABLES
rem ---------------------------------------------------------


MOVEMENT_TABLE_DATA:
    DB ROOM_FOREST_CLEARING,0,0,0
    DB 0,0,ROOM_DARK_FOREST,ROOM_CLOVER_FIELD
    DB ROOM_FOREST_CLEARING,ROOM_RIVER_CLIFF,ROOM_RIVER_CLIFF,0
    DB ROOM_FOREST_CLEARING,ROOM_RIVER_CLIFF,0,ROOM_MT_YMIR_SLOPE
    DB 0,ROOM_RIVER_BANK,ROOM_DARK_FOREST,ROOM_CLOVER_FIELD
    DB ROOM_RIVER_CLIFF,0,ROOM_CRATER_EDGE,ROOM_RIVER_OUTCROP
    DB 0,0,128,ROOM_RIVER_BANK
    DB 0,0,ROOM_RIVER_BANK,0
    DB 0,ROOM_BRIDGE_NORTH_ANCHOR,ROOM_CLOVER_FIELD,0
    DB ROOM_MT_YMIR_SLOPE,ROOM_BRIDGE_MID,ROOM_CLOVER_FIELD,0
    DB ROOM_BRIDGE_NORTH_ANCHOR,ROOM_BRIDGE_SOUTH_ANCHOR,128,128
    DB ROOM_BRIDGE_MID,ROOM_MUSHROOM_ROCK,ROOM_MUSHROOM_ROCK,0
    DB ROOM_BRIDGE_SOUTH_ANCHOR,ROOM_BRIDGE_SOUTH_ANCHOR,ROOM_CAVE_ENTRANCE_CLEARING,ROOM_BRIDGE_SOUTH_ANCHOR
    DB ROOM_CLIFF_FACE,ROOM_CAVE_ENTRY,0,ROOM_MUSHROOM_ROCK
    DB 0,ROOM_CAVE_ENTRANCE_CLEARING,0,0
    DB ROOM_CAVE_ENTRANCE_CLEARING,ROOM_DARK_CAVERN_A,0,ROOM_DEAD_END_INSCRIPTION
    DB 0,0,ROOM_CAVE_ENTRY,0
    DB ROOM_CAVE_ENTRY,0,ROOM_TORTURE_CHAMBER,0
    DB 0,0,ROOM_OAK_DOOR,0
    DB ROOM_DARK_CAVERN_B,ROOM_TORTURE_CHAMBER,0,0
    DB 0,ROOM_NORTH_SOUTH_TUNNEL,0,ROOM_OAK_DOOR
    DB 0,ROOM_TORTURE_CHAMBER,ROOM_DARK_CAVERN_B,ROOM_CAVE_ENTRY
    DB ROOM_WIND_CORRIDOR,0,ROOM_DARK_CAVERN_A,ROOM_DARK_CAVERN_A
    DB ROOM_DARK_CAVERN_B,ROOM_ROUND_ROOM,0,ROOM_DARK_CAVERN_A
    DB 0,ROOM_LEDGE_OVER_RIVER,ROOM_NORTH_SOUTH_TUNNEL,0
    DB ROOM_NORTH_SOUTH_TUNNEL,ROOM_LEDGE_OVER_RIVER,ROOM_DARK_CAVERN_D,ROOM_DARK_CAVERN_C
    DB ROOM_DARK_CAVERN_A,0,0,ROOM_TEMPLE_BALCONY
    DB 0,0,ROOM_LEDGE_OVER_RIVER,0
    DB 0,ROOM_BAT_CAVE,0,ROOM_ROUND_ROOM
    DB ROOM_DARK_CAVERN_D,ROOM_DARK_CAVERN_F,0,0
    DB ROOM_DARK_CAVERN_G,0,0,0
    DB ROOM_BAT_CAVE,ROOM_DARK_CAVERN_E,0,0
    DB 0,ROOM_DARK_CAVERN_F,ROOM_DARK_CAVERN_H,0
    DB 0,0,0,ROOM_BAT_CAVE
    DB 0,0,0,0
    DB ROOM_DARK_CAVERN_J,0,ROOM_TEMPLE,ROOM_LEDGE_WATERFALL_IN
    DB 0,ROOM_TEMPLE,0,0
    DB 0,0,0,0
    DB 0,ROOM_DARK_CAVERN_I,ROOM_TINY_CELL,0
    DB ROOM_WATERFALL_BASE,ROOM_CASTLE_LEDGE,ROOM_DARK_CAVERN_I,128
    DB ROOM_DARK_CAVERN_K,ROOM_DRAIN_C,ROOM_RIVER_CONDUIT,ROOM_DRAIN_B
    DB ROOM_DARK_CAVERN_K,ROOM_DRAIN_C,ROOM_DRAIN_A,ROOM_DRAIN_C
    DB ROOM_DARK_CAVERN_K,ROOM_TINY_CELL,ROOM_DRAIN_B,ROOM_DRAIN_D
    DB ROOM_STONE_STAIRCASE,ROOM_STONE_STAIRCASE,0,ROOM_STONE_STAIRCASE
    DB 0,ROOM_LEDGE_WATERFALL_IN,0,128
    DB ROOM_STONE_STAIRCASE,0,ROOM_STONE_STAIRCASE,ROOM_STONE_STAIRCASE
    DB 0,ROOM_WATERFALL_BASE,ROOM_DARK_CAVERN_K,0
    DB ROOM_LEDGE_WATERFALL_IN,128,0,128
    DB 0,0,ROOM_CASTLE_LEDGE,ROOM_CASTLE_COURTYARD
    DB 0,ROOM_EAST_RIVERBANK,ROOM_DRAWBRIDGE,ROOM_POWDER_MAG
    DB 0,0,ROOM_CASTLE_COURTYARD,0
    DB ROOM_CASTLE_COURTYARD,0,ROOM_WOODEN_BRIDGE,ROOM_CASTLE_COURTYARD
    DB ROOM_RIVER_CONDUIT,0,0,ROOM_EAST_RIVERBANK
    DB 0,ROOM_WOODEN_BRIDGE,ROOM_DRAIN_A,0


OBJECT_LOCATION_DATA:
    DW ROOM_DARK_CAVERN_I, ROOM_TREASURE_ROOM, ROOM_BRIDGE_NORTH_ANCHOR, ROOM_CAVE_ENTRANCE_CLEARING
    DW ROOM_DEAD_END_INSCRIPTION, ROOM_STONE_STAIRCASE, ROOM_RIVER_OUTCROP, ROOM_DARK_ROOM
    DW ROOM_POWDER_MAG, ROOM_WATERFALL_BASE, ROOM_WIND_CORRIDOR, ROOM_DARK_CAVERN_K
    DW ROOM_RIVER_CONDUIT, ROOM_TREASURE_ROOM, ROOM_TREASURE_ROOM, ROOM_TREASURE_ROOM
    DW ROOM_TREASURE_ROOM, EXIT_NONE, ROOM_DARK_CAVERN_H, ROOM_CRATER_EDGE
    DW ROOM_DARK_CAVERN_A, ROOM_CLIFF_FACE, ROOM_NORTH_SOUTH_TUNNEL, ROOM_TINY_CELL


ROOM_DESC1_PTR:
    DW DESC_DARK_ROOM, DESC_FOREST_CLEARING, DESC_DARK_FOREST
    DW DESC_CLOVER_FIELD, DESC_RIVER_CLIFF, DESC_RIVER_BANK
    DW DESC_CRATER_EDGE, DESC_RIVER_OUTCROP, DESC_MT_YMIR
    DW DESC_BRIDGE_NORTH, DESC_BRIDGE_MID, DESC_BRIDGE_SOUTH
    DW DESC_MUSHROOM_ROCK, DESC_CAVE_CLEARING, DESC_CLIFF_FACE
    DW DESC_CAVE_ENTRY, DESC_DEAD_END, NULL
    DW DESC_TREASURE_ROOM, DESC_OAK_DOOR, NULL, DESC_WIND_CORRIDOR
    DW DESC_TORTURE_CHAMBER, DESC_NS_TUNNEL, NULL, DESC_ROUND_ROOM
    DW DESC_LEDGE_RIVER, DESC_TEMPLE_BALCONY
    DW NULL, NULL, NULL, NULL, DESC_BAT_CAVE, NULL, DESC_TEMPLE
    DW NULL, DESC_CRYPT, DESC_TINY_CELL, NULL, DESC_WATERFALL_LEDGE
    DW NULL, NULL, NULL, NULL, DESC_WATERFALL_BASE, NULL, DESC_STONE_STAIR
    DW DESC_CASTLE_LEDGE, DESC_DRAWBRIDGE, DESC_CASTLE_COURTYARD
    DW DESC_POWDER_MAG, DESC_EAST_BANK, DESC_WOODEN_BRIDGE
    DW DESC_RIVER_CONDUIT

ROOM_DESC2_PTR:
    DW NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
    DW NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
    DW NULL, NULL, NULL, NULL, DESC_TORTURE_CHAMBER2, NULL, NULL, DESC_ROUND_ROOM2, NULL, DESC_TEMPLE_BALCONY2
    DW NULL, NULL, NULL, NULL, DESC_BAT_CAVE2, NULL, NULL, NULL, DESC_CRYPT2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL

DESC_DARK_ROOM: DB "You are standing in a darkened room. There is a door to the north.",0
DESC_FOREST_CLEARING: DB "You are in a forest clearing before a small bark hut. There are no windows, and locked door to the south. The latch was engaged when you closed the door.",0
DESC_DARK_FOREST: DB "You are deep in a dark forest. In the distance you can see a mighty river.",0
DESC_CLOVER_FIELD: DB "You are standing in a field of four-leafed clovers. There is a small hut to the north.",0
DESC_RIVER_CLIFF: DB "The forest has opened up at this point. You are standing on a cliff overlooking a wide glacial river. A small foot-beaten path leads south.",0
DESC_RIVER_BANK: DB "You are standing at the rocky edge of the mighty river Gioll. The path forks east and west.",0
DESC_CRATER_EDGE: DB "You are on the edge of an enormous crater. The rim is extremely slippery. Clouds of water vapour rise high in the air as the Gioll pours into it.",0
DESC_RIVER_OUTCROP: DB "The path to the east stops here. You are on a rocky outcrop, projected about 15 feet above the river. In the distance, a tiny bridge spans the river.",0
DESC_MT_YMIR: DB "You are on the lower slopes of Mt. Ymir. The forest stretches far away and to the west. Arctic winds blow fiercely, it's very cold!",0
DESC_BRIDGE_NORTH: DB "You stand on a rocky precipice high above the river, Gioll; Mt. Ymir stands to the north. A flimsy string bridge spans the mighty river.",0
DESC_BRIDGE_MID: DB "You have made your way half way across the creaking bridge. It sways violently from side to side. It's going to collapse any second!!",0
DESC_BRIDGE_SOUTH: DB "You are on the southern edge of the mighty river, before the string bridge.",0
DESC_MUSHROOM_ROCK: DB "You are standing on a rock in the middle of a mighty oak forest. Surrounding you are thousands of poisonous mushrooms.",0
DESC_CAVE_CLEARING: DB "You are in a clearing in the forest. An ancient basalt rock formation towers above you. To your south is the entrance of a VERY interesting cave...",0
DESC_CLIFF_FACE: DB "You are on a cliff face over looking the river.",0
DESC_CAVE_ENTRY: DB "You are just inside the cave. Sunlight pours into the cave lighting a path to the east and another to the south. I don't mind saying I'm a bit scared!",0
DESC_DEAD_END: DB "This passage appears to be a dead end. On a wall before you is carved `Find the Sacred Key of Thialfi'.",0
DESC_TREASURE_ROOM: DB "You are in the legendary treasure room of the black elves of Svartalfheim. Every red-blooded Viking has dreamed of entering this sacred room.",0
DESC_OAK_DOOR: DB "You can see a small oak door to the east. It has been locked from the inside.",0
DESC_WIND_CORRIDOR: DB "You are standing in an east-west corridor. You can feel a faint breeze coming from the east.",0
DESC_TORTURE_CHAMBER: DB "You are standing in what appears to have once been a torture chamber. Apart from the rather comprehensive range of instumentsof absolutely inhuman agony,",0
DESC_TORTURE_CHAMBER2: DB "coagulated blood stains on the walls and mangled bits of bone on the floor make me think that a number of would be adventurers croaked it here!",0
DESC_NS_TUNNEL: DB "You stand in a long tunnel which has been bored out of the rock.It runs from north to south. A faint glow comes from a narrow crack in the eastern wall.",0
DESC_ROUND_ROOM: DB "You are in a large round room with a number of exits. The walls have been painted in a mystical dark purple and a big chalk staris drawn in the centre of ",0
DESC_ROUND_ROOM2: DB "the floor. Note: This is one of the hidden chambers of the infamous pagan sect, the monks of Loki. Norse folk believe them to be gods.",0
DESC_LEDGE_RIVER: DB "You are standing on a narrow ledge, high above a subterranean river. There is an exit to the east.",0
DESC_TEMPLE_BALCONY: DB "You are on a balcony, overlooking a huge cavern which has been converted into a pagan temple. Note: this temple has been dedicated to Loki, the god of",0
DESC_TEMPLE_BALCONY2: DB "fire, who came to live in Svartalfheim after he had been banished to exile by Odin. Since then he has been waiting for the `End Of All Things'.",0
DESC_BAT_CAVE: DB "You are in the central cave of a giant bat colony. Above you hundreds of giant bats hang from the ceiling and the floor is covered in centuries of ",0
DESC_BAT_CAVE2: DB "giant bat droppings. Careful where you step! Incidentally, the smell is indescribable.",0
DESC_TEMPLE: DB "You are in the temple. To the north is a locked gate and on the wall is a giant statue of Loki, carved out of the living rock itself!",0
DESC_CRYPT: DB "You stand in an old and musty crypt, the final resting place of hundreds of Loki devotees. On the wall is carved:``What 3 letter word completes a word ",0
DESC_CRYPT2: DB "starting with 'G---' and another ending with '---X'' Note: The monks of Loki must have liked silly puzzles. Putrefaction and decay fills the air here.",0
DESC_TINY_CELL: DB "You are in a tiny cell. The western wall has now firmly closed again. There is a ventilator shaft on the eastern wall.",0
DESC_WATERFALL_LEDGE: DB "You are on another ledge high above a subterranean river. The water flows in through a hole in the cavern roof, to the north.",0
DESC_WATERFALL_BASE: DB "You are standing near an enormous waterfall which brings water down from the surface, from the river Gioll.",0
DESC_STONE_STAIR: DB "You are standing before a stone staircase which leads southwards.",0
DESC_CASTLE_LEDGE: DB "You are on a narrow and crumbling ledge. On the other side of the river you can see a magic castle. (Don't ask me why it's magic...I just know it is)",0
DESC_DRAWBRIDGE: DB "You are by the drawbridge which has just lowered itself....by magic!!",0
DESC_CASTLE_COURTYARD: DB "You are in the courtyard of the magic castle. WOW! This castle is really something! On the wall is inscribed 'hzb tzozi'. A secret escape tunnel leads south",0
DESC_POWDER_MAG: DB "You are in the powder magazine of this really super castle.",0
DESC_EAST_BANK: DB "You are on the eastern side of the river. A small tunnel leads east into the cliff face.",0
DESC_WOODEN_BRIDGE: DB "You stand before a small wooden bridge which crosses the river.",0
DESC_RIVER_CONDUIT: DB "You are in a conduit draining into the river. The water comes up to your knees and is freezing cold. A narrow service path leads south.",0


VERB_PATTERN_DATA:
    DW VERB_TAKE, VERB_PUT, VERB_USING, VERB_WITH, VERB_CUT
    DW VERB_BREAK, VERB_UNLOCK, VERB_OPEN, VERB_KILL, VERB_ATTACK
    DW VERB_LIGHT, VERB_BURN, VERB_UP, VERB_DOWN, VERB_JUMP, VERB_SWIM

VERB_TAKE: DB "take",0
VERB_PUT: DB "put",0
VERB_USING: DB "using",0
VERB_WITH: DB "with",0
VERB_CUT: DB "cut",0
VERB_BREAK: DB "break",0
VERB_UNLOCK: DB "unlock",0
VERB_OPEN: DB "open",0
VERB_KILL: DB "kill",0
VERB_ATTACK: DB "attack",0
VERB_LIGHT: DB "light",0
VERB_BURN: DB "burn",0
VERB_UP: DB "up",0
VERB_DOWN: DB "down",0
VERB_JUMP: DB "jump",0
VERB_SWIM: DB "swim",0

DIR_WORD_INDEX_DATA:
    DW DIR_NORTH_STR, DIR_SOUTH_STR, DIR_WEST_STR, DIR_EAST_STR

DIR_NORTH_STR: DB " north ",0
DIR_SOUTH_STR: DB " south ",0
DIR_WEST_STR: DB " west ",0
DIR_EAST_STR: DB " east ",0


rem NOTE: article handling (a/an) and leading/trailing spaces in strings to be normalized later via an article routine
MONSTER_ADJ_DATA:
    DW MON_ADJ_WIZ, MON_ADJ_DEMON, MON_ADJ_TROLL, MON_ADJ_DRAGON, MON_ADJ_BAT, MON_ADJ_DWARF

MON_ADJ_WIZ: DB "n evil",0
MON_ADJ_DEMON: DB " fiery",0
MON_ADJ_TROLL: DB "n axe wielding",0
MON_ADJ_DRAGON: DB " fire breathing",0
MON_ADJ_BAT: DB " giant",0
MON_ADJ_DWARF: DB "n old and gnarled",0

MONSTER_NOUN_DATA:
    DW MON_NOUN_WIZ, MON_NOUN_DEMON, MON_NOUN_TROLL, MON_NOUN_DRAGON, MON_NOUN_BAT, MON_NOUN_DWARF

MON_NOUN_WIZ: DB " wizard ",0
MON_NOUN_DEMON: DB " demon ",0
MON_NOUN_TROLL: DB " troll ",0
MON_NOUN_DRAGON: DB " dragon ",0
MON_NOUN_BAT: DB " bat ",0
MON_NOUN_DWARF: DB " dwarf ",0

rem NOTE: article handling (a/an) and trimming leading/trailing padding spaces to be addressed later
OBJECT_NAME_ADJ_DATA:
    DW OBJ_ADJ_COIN, OBJ_ADJ_COMPASS, OBJ_ADJ_BOMB, OBJ_ADJ_RUBY, OBJ_ADJ_DIAMOND, OBJ_ADJ_PEARL, OBJ_ADJ_STONE, OBJ_ADJ_RING, OBJ_ADJ_PENDANT, OBJ_ADJ_GRAIL, OBJ_ADJ_SHIELD
    DW OBJ_ADJ_BOX, OBJ_ADJ_KEY, OBJ_ADJ_SWORD, OBJ_ADJ_CANDLE, OBJ_ADJ_ROPE, OBJ_ADJ_BRICK, OBJ_ADJ_GRILL

OBJ_ADJ_COIN: DB " gold",0
OBJ_ADJ_COMPASS: DB " useful looking",0
OBJ_ADJ_BOMB: DB " home made",0
OBJ_ADJ_RUBY: DB " blood red",0
OBJ_ADJ_DIAMOND: DB " sparkling",0
OBJ_ADJ_PEARL: DB " moon-like",0
OBJ_ADJ_STONE: DB "n interesting",0
OBJ_ADJ_RING: DB " diamond studded",0
OBJ_ADJ_PENDANT: DB " magic",0
OBJ_ADJ_GRAIL: DB " most holy",0
OBJ_ADJ_SHIELD: DB " mirror like",0
OBJ_ADJ_BOX: DB " nondescript black",0
OBJ_ADJ_KEY: DB "n old an rusty",0
OBJ_ADJ_SWORD: DB " double bladed",0
OBJ_ADJ_CANDLE: DB " small",0
OBJ_ADJ_ROPE: DB " thin and tatty",0
OBJ_ADJ_BRICK: DB " red house",0
OBJ_ADJ_GRILL: DB " rusty ventilation",0

OBJECT_NAME_NOUN_DATA:
    DW OBJ_NOUN_COIN, OBJ_NOUN_COMPASS, OBJ_NOUN_BOMB, OBJ_NOUN_RUBY, OBJ_NOUN_DIAMOND, OBJ_NOUN_PEARL, OBJ_NOUN_STONE, OBJ_NOUN_RING, OBJ_NOUN_PENDANT, OBJ_NOUN_GRAIL, OBJ_NOUN_SHIELD
    DW OBJ_NOUN_BOX, OBJ_NOUN_KEY, OBJ_NOUN_SWORD, OBJ_NOUN_CANDLE, OBJ_NOUN_ROPE, OBJ_NOUN_BRICK, OBJ_NOUN_GRILL

OBJ_NOUN_COIN: DB " coin ",0
OBJ_NOUN_COMPASS: DB " compass ",0
OBJ_NOUN_BOMB: DB " bomb ",0
OBJ_NOUN_RUBY: DB " ruby ",0
OBJ_NOUN_DIAMOND: DB " diamond ",0
OBJ_NOUN_PEARL: DB " pearl ",0
OBJ_NOUN_STONE: DB " stone ",0
OBJ_NOUN_RING: DB " ring ",0
OBJ_NOUN_PENDANT: DB " pendant ",0
OBJ_NOUN_GRAIL: DB " grail ",0
OBJ_NOUN_SHIELD: DB " shield ",0
OBJ_NOUN_BOX: DB " box ",0
OBJ_NOUN_KEY: DB " key ",0
OBJ_NOUN_SWORD: DB " sword ",0
OBJ_NOUN_CANDLE: DB " candle ",0
OBJ_NOUN_ROPE: DB " rope ",0
OBJ_NOUN_BRICK: DB " brick ",0
OBJ_NOUN_GRILL: DB " grill ",0

OBJDESC1_DATA:
    DW MON_ADJ_WIZ, MON_ADJ_DEMON, MON_ADJ_TROLL
    DW MON_ADJ_DRAGON, MON_ADJ_BAT, MON_ADJ_DWARF
    DW OBJ_ADJ_COIN, OBJ_ADJ_COMPASS, OBJ_ADJ_BOMB, OBJ_ADJ_RUBY
    DW OBJ_ADJ_DIAMOND, OBJ_ADJ_PEARL, OBJ_ADJ_STONE, OBJ_ADJ_RING
    DW OBJ_ADJ_PENDANT, OBJ_ADJ_GRAIL, OBJ_ADJ_SHIELD, OBJ_ADJ_BOX
    DW OBJ_ADJ_KEY, OBJ_ADJ_SWORD, OBJ_ADJ_CANDLE, OBJ_ADJ_ROPE
    DW OBJ_ADJ_BRICK, OBJ_ADJ_GRILL

OBJDESC2_DATA:
    DW MON_NOUN_WIZ, MON_NOUN_DEMON, MON_NOUN_TROLL
    DW MON_NOUN_DRAGON, MON_NOUN_BAT, MON_NOUN_DWARF
    DW OBJ_NOUN_COIN, OBJ_NOUN_COMPASS, OBJ_NOUN_BOMB, OBJ_NOUN_RUBY
    DW OBJ_NOUN_DIAMOND, OBJ_NOUN_PEARL, OBJ_NOUN_STONE, OBJ_NOUN_RING
    DW OBJ_NOUN_PENDANT, OBJ_NOUN_GRAIL, OBJ_NOUN_SHIELD, OBJ_NOUN_BOX
    DW OBJ_NOUN_KEY, OBJ_NOUN_SWORD, OBJ_NOUN_CANDLE, OBJ_NOUN_ROPE
    DW OBJ_NOUN_BRICK, OBJ_NOUN_GRILL


UPDATE_DYNAMIC_EXITS_SUB:

    rem Patch dynamic exits in movement table
    rem Dynamic exit slots patched at runtime (room, direction):
    rem (ROOM_BRIDGE_NORTH_ANCHOR,DIR_SOUTH_STR)=BRIDGE_CONDITION
    rem (ROOM_BRIDGE_SOUTH_ANCHOR,DIR_NORTH_STR)=BRIDGE_CONDITION
    rem (ROOM_OAK_DOOR,DIR_EAST_STR)=TELEPORT_DESTINATION
    rem (ROOM_CRYPT,DIR_EAST_STR)=SECRET_EXIT_LOCATION
    rem (ROOM_TINY_CELL,DIR_NORTH_STR)=WATER_EXIT_LOCATION
    rem (ROOM_TINY_CELL,DIR_EAST_STR)=GATE_DESTINATION
    rem (ROOM_CASTLE_LEDGE,DIR_EAST_STR)=DRAWBRIDGE_STATE

    MOVEMENT_TABLE(ROOM_BRIDGE_NORTH_ANCHOR,DIR_SOUTH_STR) = BRIDGE_CONDITION
    MOVEMENT_TABLE(ROOM_BRIDGE_SOUTH_ANCHOR,DIR_NORTH_STR) = BRIDGE_CONDITION
    MOVEMENT_TABLE(ROOM_OAK_DOOR,DIR_EAST_STR) = TELEPORT_DESTINATION
    MOVEMENT_TABLE(ROOM_CRYPT,DIR_EAST_STR) = SECRET_EXIT_LOCATION
    MOVEMENT_TABLE(ROOM_TINY_CELL,DIR_NORTH_STR) = WATER_EXIT_LOCATION
    MOVEMENT_TABLE(ROOM_TINY_CELL,DIR_EAST_STR) = GATE_DESTINATION
    MOVEMENT_TABLE(ROOM_CASTLE_LEDGE,DIR_EAST_STR) = DRAWBRIDGE_STATE
    return
